<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Game: Atlantic Village</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Orbitron for Sci-Fi look + Inter for UI -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            /* Palette extracted from reference image */
            --bg-deep: #0b0c15;
            --bg-panel: #131620; /* Dark Blue-Grey */
            --bg-card: rgba(19, 22, 32, 0.8);
            
            --border-glow: rgba(0, 240, 255, 0.3);
            --border-active: #00f0ff;
            
            --neon-cyan: #00f3ff;
            --neon-pink: #ff0055;
            --neon-purple: #bc13fe;
            --neon-green: #00ff9d;
            --neon-orange: #ff9d00;
            
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-deep);
            background-image: radial-gradient(circle at 50% 50%, #1a1d2e 0%, #0b0c15 100%);
            color: #e2e8f0;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out;
            height: 100vh;
        }

        /* Sci-Fi Headings */
        h1, h2, h3, .digit-font {
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
        }

        /* --- Start Screen --- */
        #start-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 6, 10, 0.98); /* Darker opacity */
            backdrop-filter: blur(20px);
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease;
        }

        /* Basic Smooth Title Design */
        .title-main {
            font-size: 5rem;
            font-weight: 800;
            font-family: 'Orbitron', sans-serif;
            color: #ffffff;
            text-shadow: 
                0 0 20px rgba(0, 243, 255, 0.6),
                0 0 40px rgba(0, 243, 255, 0.3);
            letter-spacing: 0.15em;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        .title-sub {
            font-family: 'Inter', sans-serif;
            color: var(--neon-cyan);
            font-size: 1.1rem;
            letter-spacing: 0.5em;
            font-weight: 600;
            margin-top:1.5rem;
            margin-bottom: 3rem;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .menu-btn {
            background: rgba(0, 243, 255, 0.05);
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
            padding: 1rem 2.5rem;
            font-size: 1.2rem;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover {
            background: var(--neon-cyan);
            color: #000;
            box-shadow: 0 0 25px var(--neon-cyan);
            transform: translateY(-2px);
        }

        .menu-btn-secondary {
            border-color: var(--neon-purple);
            color: var(--neon-purple);
            background: rgba(188, 19, 254, 0.05);
            font-size: 0.9rem;
            padding: 1rem 2rem;
        }

        .menu-btn-secondary:hover {
            background: var(--neon-purple);
            color: white;
            box-shadow: 0 0 25px var(--neon-purple);
        }

        /* Info Box Styles */
        .info-overlay-box {
            background: rgba(11, 12, 21, 0.98);
            border: 2px solid rgba(0, 240, 255, 0.3);
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.2), inset 0 0 30px rgba(0, 243, 255, 0.05);
            border-radius: 12px;
            padding: 0.8rem;
            max-width: 1400px;
            width: 98%;
            max-height: 90vh;
            overflow-y: auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 300;
        }

        .rules-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.6rem;
        }

        .rule-section {
            background: rgba(19, 22, 32, 0.6);
            border-left: 3px solid var(--neon-cyan);
            border-radius: 8px;
            padding: 0.5rem;
            margin-bottom: 0;
        }

        .rule-section:nth-child(3n+1) { border-left-color: var(--neon-cyan); }
        .rule-section:nth-child(3n+2) { border-left-color: var(--neon-pink); }
        .rule-section:nth-child(3n) { border-left-color: var(--neon-green); }

        .rule-title { 
            color: var(--neon-orange); 
            font-family: 'Orbitron', sans-serif; 
            margin-bottom: 0.2rem; 
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .rule-text { 
            color: #cbd5e1; 
            font-size: 0.7rem; 
            line-height: 1.2;
        }
        .rule-text li { margin-bottom: 0.1rem; }
        .rule-text strong { color: var(--neon-cyan); }

        /* --- Glass Panels --- */
        .glass-panel {
            background: rgba(19, 22, 32, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(100, 116, 139, 0.3);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0,0,0,0.2);
            border-radius: 12px;
        }

        .glass-panel-header {
            background: linear-gradient(90deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 10px 16px;
            color: #a0aec0;
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            border-radius: 12px 12px 0 0;
            font-family: 'Orbitron', sans-serif;
        }

        /* --- Buttons & Inputs --- */
        .tech-btn {
            background: linear-gradient(180deg, rgba(30, 41, 59, 0.8) 0%, rgba(15, 23, 42, 0.9) 100%);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 12px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .tech-btn:hover {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
            transform: translateY(-2px);
        }

        .region-card {
            background: rgba(30, 41, 59, 0.7);
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 1.5rem;
            text-align: left;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .region-card:hover {
            border-color: var(--neon-cyan);
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(0, 243, 255, 0.1);
        }

        .tech-btn.selected {
            background: linear-gradient(180deg, rgba(6, 182, 212, 0.2) 0%, rgba(8, 145, 178, 0.1) 100%);
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.5), inset 0 0 10px rgba(0, 243, 255, 0.2);
        }

        /* --- Select Dropdown --- */
        select.region-select {
            background: #1e293b;
            color: var(--neon-cyan);
            border: 1px solid rgba(0, 243, 255, 0.3);
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            outline: none;
            transition: all 0.2s;
        }
        select.region-select:hover {
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
            border-color: var(--neon-cyan);
        }

        /* Advisor Bubble */
        .advisor-row {
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        .advisor-avatar {
            width: 75px;
            height: 75px;
            border-radius: 25%;
            overflow: hidden;
            border: 2px solid rgba(0, 243, 255, 0.4);
            box-shadow: 0 0 12px rgba(0, 243, 255, 0.2);
            background: #0b0c15;
            flex-shrink: 0;
        }
        .advisor-avatar img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .advisor-bubble {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(0, 243, 255, 0.35);
            box-shadow: 0 0 18px rgba(0, 243, 255, 0.15);
            border-radius: 12px 12px 12px 4px;
            padding: 12px 14px;
            color: #e2e8f0;
            font-size: 0.85rem;
            line-height: 1.4;
            position: relative;
        }
        .advisor-bubble::after {
            content: "";
            position: absolute;
            left: -10px;
            bottom: 12px;
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            border-right: 10px solid rgba(0, 243, 255, 0.35);
        }

        /* --- Tutorial Overlay System --- */
        #tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 998;
            pointer-events: none;
            display: none;
        }

        #tutorial-overlay.active {
            display: block;
        }

        .tutorial-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1;
        }

        .tutorial-spotlight {
            position: absolute;
            border-radius: 8px;
            z-index: 2;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            transition: all 0.4s ease;
        }

        .tutorial-box {
            position: fixed;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95) 0%, rgba(30, 41, 59, 0.95) 100%);
            border: 2px solid var(--neon-cyan);
            border-radius: 12px;
            padding: 30px;
            max-width: 450px;
            z-index: 3;
            pointer-events: all;
            animation: slideIn 0.4s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tutorial-box h2 {
            color: var(--neon-orange);
            font-size: 1.5em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 157, 0, 0.5);
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-box p {
            color: #d0d0d0;
            font-size: 1em;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .tutorial-step-indicator {
            font-size: 0.9em;
            color: var(--neon-cyan);
            margin-bottom: 15px;
            font-weight: 600;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-button {
            background: linear-gradient(135deg, var(--neon-cyan) 0%, #0099cc 100%);
            color: #000;
            border: none;
            padding: 12px 30px;
            font-size: 1em;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-button:hover {
            transform: scale(1.05);
        }

        .tutorial-button:active {
            transform: scale(0.98);
        }

        .tutorial-box.centered {
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%);
            max-width: 500px;
            filter: drop-shadow(0 0 6px rgba(0, 243, 255, 0.25));
        }

        /* --- Post-Region Game Tutorial Overlay --- */
        #game-tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            pointer-events: none;
            display: none;
            background: rgba(0, 0, 0, 0.85);
        }

        #game-tutorial-overlay.active {
            display: block;
            pointer-events: auto;
        }

        .tutorial-spotlight-game {
            position: absolute;
            border-radius: 12px;
            z-index: 1000;
            pointer-events: none;
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: none;
        }

        .tutorial-box-game {
            position: fixed;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98) 0%, rgba(30, 41, 59, 0.98) 100%);
            border: 2px solid var(--neon-cyan);
            border-radius: 12px;
            padding: 40px;
            max-width: 550px;
            box-shadow: 0 20px 80px rgba(0, 0, 0, 0.95),
                        0 0 60px rgba(0, 243, 255, 0.5);
            z-index: 1001;
            pointer-events: all;
            animation: slideInTutorial 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        @keyframes slideInTutorial {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tutorial-box-game h2 {
            color: var(--neon-orange);
            font-size: 1.8em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 157, 0, 0.6);
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-box-game p {
            color: #d0d0d0;
            font-size: 1.05em;
            line-height: 1.8;
            margin-bottom: 25px;
            font-family: 'Inter', sans-serif;
        }

        .tutorial-step-indicator-game {
            font-size: 0.95em;
            color: var(--neon-cyan);
            margin-bottom: 20px;
            font-weight: 600;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tutorial-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .tutorial-button-secondary {
            background: rgba(100, 116, 139, 0.3);
            color: #cbd5e1;
            border: 1px solid rgba(100, 116, 139, 0.5);
            padding: 12px 24px;
            font-size: 0.95em;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'Orbitron', sans-serif;
        }

        .tutorial-button-secondary:hover {
            background: rgba(100, 116, 139, 0.5);
            border-color: rgba(100, 116, 139, 0.8);
            color: #fff;
            transform: translateY(-2px);
        }

        .tutorial-box-game.centered {
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
        }
        .advisor-meta {
            font-size: 10px;
            color: #94a3b8;
            margin-bottom: 4px;
            letter-spacing: 0.08em;
        }
        .advisor-bubble.error {
            border-color: rgba(239, 68, 68, 0.6);
            box-shadow: 0 0 18px rgba(239, 68, 68, 0.25);
        }
        /* --- Grid --- */
        .map-container-2d {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .map-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 4px;
            width: 100%; 
            aspect-ratio: 1/1;
            padding: 4px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .build-cursor {
            position: fixed;
            width: 44px;
            height: 44px;
            border-radius: 9999px;
            background: rgba(0, 243, 255, 0.08);
            border: 1px solid var(--border-active);
            box-shadow: 0 0 16px rgba(0, 243, 255, 0.35);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 120;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(6px);
        }

        .tile {
            position: relative;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.1s;
            background-color: #1e293b; /* Default Land */
            border: 1px solid rgba(255,255,255,0.1);
        }

        .tile.sun-boosted {
            box-shadow: inset 0 0 8px rgba(250, 204, 21, 0.4), 0 0 8px rgba(250, 204, 21, 0.2);
            border-color: rgba(250, 204, 21, 0.3);
        }

        .tile:hover {
            border-color: white;
            box-shadow: 0 0 15px rgba(0,243,255,0.2);
            z-index: 10;
            transform: scale(1.05);
        }

        .tile-river {
            background: linear-gradient(120deg, #0ea5e9, #38bdf8, #0284c7);
            background-size: 200% 200%;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2); 
            border: 1px solid #38bdf8;
            animation: river-flow 5s linear infinite, pulse-river 3s infinite alternate;
        }

        @keyframes pulse-river {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.2); }
        }

        @keyframes river-flow {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        .tile-forest {
            background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            border: 1px solid #15803d;
            cursor: not-allowed !important;
        }

        .tile-mountain {
            background: linear-gradient(180deg, #a1a1aa 0%, #71717a 100%);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.4);
            border: 1px solid #52525b;
            cursor: not-allowed !important;
        }

        /* --- Construction & Effects --- */
        .tile-construction {
            background: repeating-linear-gradient(
                45deg,
                #1e1b4b,
                #1e1b4b 10px,
                #312e81 10px,
                #312e81 20px
            ) !important;
            border: 1px dashed #facc15 !important;
            cursor: wait !important;
        }

        /* Standard Flat Icons */
        .tile svg.lucide {
            transform: none;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
            transition: transform 0.2s;
        }
        
        .tile:hover svg.lucide {
             transform: scale(1.1);
        }

        /* Broken State Visuals */
        .tile-broken {
            background-color: #2a1010 !important;
            border: 2px solid #ef4444 !important;
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            75% { transform: translateX(2px); }
        }

        .smoke-overlay {
            position: absolute;
            top: -10px; right: 0; left: 0; margin: auto;
            color: #9ca3af;
            font-size: 20px;
            text-align: center;
            animation: float-smoke 2s infinite linear;
            z-index: 40;
            pointer-events: none;
        }
        
        @keyframes float-smoke {
            0% { transform: translateY(0) scale(1); opacity: 0.8; }
            100% { transform: translateY(-10px) scale(1.5); opacity: 0; }
        }

        .build-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background-color: #00ff9d;
            width: 0%;
            transition: width 5s linear;
            z-index: 30;
        }

        /* --- Building Efficiency Glow Effects --- */
        .building-glow-low {
            box-shadow: 0 0 8px rgba(100, 116, 139, 0.4), inset 0 0 8px rgba(100, 116, 139, 0.2);
            transition: box-shadow 0.3s ease;
        }

        .building-glow-medium {
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.6), inset 0 0 10px rgba(59, 130, 246, 0.3);
            transition: box-shadow 0.3s ease;
        }

        .building-glow-high {
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.8), inset 0 0 15px rgba(34, 211, 238, 0.4);
            transition: box-shadow 0.3s ease;
        }

        .building-glow-optimal {
            box-shadow: 0 0 30px rgba(0, 255, 157, 0.9), inset 0 0 20px rgba(0, 255, 157, 0.5), 
                        0 0 50px rgba(0, 255, 157, 0.4);
            transition: box-shadow 0.3s ease;
            animation: glow-pulse 1.5s ease-in-out infinite;
        }

        @keyframes glow-pulse {
            0%, 100% { 
                box-shadow: 0 0 30px rgba(0, 255, 157, 0.9), inset 0 0 20px rgba(0, 255, 157, 0.5), 
                            0 0 50px rgba(0, 255, 157, 0.4);
            }
            50% { 
                box-shadow: 0 0 40px rgba(0, 255, 157, 1), inset 0 0 25px rgba(0, 255, 157, 0.6), 
                            0 0 70px rgba(0, 255, 157, 0.5);
            }
        }

        /* --- Disaster Effects --- */
        .effect-cloud::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(2px);
            z-index: 20;
            pointer-events: none;
            animation: cloud-drift 4s infinite alternate;
        }

        @keyframes cloud-drift {
            0% { transform: translateX(-2px); }
            100% { transform: translateX(2px); }
        }

        .effect-drought {
            background: #5d4037 !important; /* Dried mud color */
            border-color: #3e2723 !important;
            animation: none !important;
            box-shadow: inset 0 0 10px #000 !important;
        }

        .tile-town {
            background: #1e1b4b; /* Dark Indigo */
            border: 1px solid #4338ca;
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.3);
            cursor: not-allowed !important;
            transition: all 0.5s ease;
        }

        .tile-town-off {
            background: #0f0f12 !important; /* Blackout */
            border: 1px solid #1f1f2e !important;
            box-shadow: none !important;
        }

        .effect-storm-overlay {
            position: absolute;
            top: 0; left: 0; w-full; h-full;
            background: rgba(255, 0, 0, 0.1);
            pointer-events: none;
            z-index: 50;
            display: none;
        }

        /* --- Progress Bars (Gradients) --- */
        .bar-container {
            background: rgba(0,0,0,0.4);
            border-radius: 99px;
            height: 12px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .bar-fill {
            height: 100%;
            border-radius: 99px;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .grad-blue { background: linear-gradient(90deg, #22d3ee 0%, #3b82f6 100%); }
        .grad-pink { background: linear-gradient(90deg, #f472b6 0%, #db2777 100%); }
        .grad-green { background: linear-gradient(90deg, #4ade80 0%, #16a34a 100%); }
        .grad-orange { background: linear-gradient(90deg, #fbbf24 0%, #ea580c 100%); }

        /* --- Text Glows --- */
        .text-neon-cyan { color: var(--neon-cyan); text-shadow: 0 0 8px rgba(0, 243, 255, 0.5); }
        .text-neon-pink { color: var(--neon-pink); text-shadow: 0 0 8px rgba(255, 0, 85, 0.5); }
        .text-neon-green { color: var(--neon-green); text-shadow: 0 0 8px rgba(0, 255, 157, 0.5); }
        
        /* --- Summary & Start Modals --- */
        .modal-backdrop {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .modal-backdrop.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: #131620;
            border: 2px solid #4338ca;
            box-shadow: 0 0 40px rgba(99, 102, 241, 0.2);
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            padding: 2rem;
            text-align: center;
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }
        
        .modal-backdrop.visible .modal-content {
            transform: translateY(0);
        }

        .stat-box {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 1rem;
            border-radius: 8px;
        }
        

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    </style>
</head>
<body class="flex flex-col h-screen text-sm select-none">

    <!-- Audio Elements -->
    <audio id="bg-music" src="music/background_music.mp3" loop></audio>
    <audio id="sound-success" src="music/game_good_job.mp3"></audio>
    <audio id="sound-fail" src="music/game_over.mp3"></audio>
    <audio id="sound-build" src="music/building.mp3"></audio>
    <audio id="sound-destroy" src="music/destroy_building.mp3"></audio>

    <!-- Start Screen -->
    <div id="start-screen">
        <div class="title-main">ENERGY ATLAS</div>
        <div class="title-sub">Grid Management Simulation</div>
        
        <div class="flex gap-4 z-50">
            <button onclick="game.dismissStartScreen()" class="menu-btn font-bold">
                START MISSION
            </button>
            
            <button onclick="game.toggleRules()" class="menu-btn menu-btn-secondary">
                RULES
            </button>

            <button onclick="game.toggleHighScores()" class="menu-btn menu-btn-secondary">
                RECORDS
            </button>
        </div>

        <!-- Rules Panel -->
        <div id="rules-list" class="info-overlay-box hidden mt-8">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-neon-cyan font-bold text-2xl tracking-widest flex items-center gap-2">
                    <i data-lucide="zap" class="w-6 h-6"></i>MISSION PROTOCOLS
                </h3>
                <button onclick="document.getElementById('rules-list').classList.add('hidden')" class="text-gray-500 hover:text-white text-2xl">✕</button>
            </div>
            
            <div class="rules-container">
                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="target" class="w-4 h-4 text-neon-cyan"></i>OBJECTIVE
                    </div>
                    <div class="rule-text">
                        Design a power grid to survive a 12-month cycle. Meet <strong>Monthly Demand</strong> while managing budget and maintaining grid stability.
                    </div>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="settings" class="w-4 h-4 text-neon-pink"></i>CORE MECHANICS
                    </div>
                    <ul class="rule-text list-disc pl-4 space-y-1 text-xs">
                        <li>Blackout = -20 pts + reliability penalty</li>
                        <li>Grace Period: 2 months after first blackout</li>
                        <li>Max 3 buildings under construction</li>
                        <li>Demand grows 2% monthly</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="solar-panel" class="w-4 h-4 text-blue-300"></i>SOLAR PANEL (450cr)
                    </div>
                    <div class="rule-text text-xs">
                        Day-only generation (50% at night). Peaks summer. Vulnerable to clouds.
                    </div>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="fan" class="w-4 h-4 text-pink-300"></i>WIND TURBINE (700cr)
                    </div>
                    <div class="rule-text text-xs">
                        <strong>⚠️ Must be 1+ tiles from Town</strong> or incur 50cr fine. Weather-dependent.
                    </div>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="dam" class="w-4 h-4 text-cyan-300"></i>HYDRO PLANT (600cr)
                    </div>
                    <div class="rule-text text-xs">
                        <strong>Requires River.</strong> Consistent power. Immune to clouds. Disabled in droughts.
                    </div>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="battery-charging" class="w-4 h-4 text-green-400"></i>BATTERY STORAGE (200cr)
                    </div>
                    <div class="rule-text text-xs">
                        Prevents blackouts. Essential for night power. Charges during peak production.
                    </div>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="zap" class="w-4 h-4 text-purple-300"></i>GRID EFFICIENCY (300cr)
                    </div>
                    <div class="rule-text text-xs">
                        +3% output boost to all generators. Stacks up to 5 times (+15% max).
                    </div>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="circle-dollar-sign" class="w-4 h-4 text-purple-400"></i>EXPORT HUB (1200cr)
                    </div>
                    <div class="rule-text text-xs">
                        Sells surplus power at 0.3 cr/MWh. Requires excess capacity.
                    </div>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="trash-2" class="w-4 h-4 text-red-400"></i>DEMOLITION (50% Refund)
                    </div>
                    <div class="rule-text text-xs">
                        Remove buildings. Recover half construction cost.
                    </div>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="map" class="w-4 h-4 text-neon-green"></i>TERRAIN TYPES
                    </div>
                    <ul class="rule-text list-disc pl-4 space-y-0 text-xs">
                        <li><span class="text-green-400">Land:</span> Buildable</li>
                        <li><span class="text-blue-400">River:</span> Hydro only</li>
                        <li><span class="text-gray-500">Mountain:</span> Obstacle</li>
                        <li><span class="text-orange-400">Town:</span> Needs power</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="cloud-lightning" class="w-4 h-4 text-yellow-400"></i>EVENTS & DISASTERS
                    </div>
                    <ul class="rule-text list-disc pl-4 space-y-0 text-xs">
                        <li><strong>Cloud:</strong> -50% solar, +20% wind</li>
                        <li><strong>Drought:</strong> Rivers disabled</li>
                        <li><strong>Breakdown:</strong> Pay 150cr to repair</li>
                        <li><strong>Noise Fine:</strong> 50cr per violation</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="award" class="w-4 h-4 text-neon-orange"></i>SCORING (0-100 each)
                    </div>
                    <ul class="rule-text list-disc pl-4 space-y-0 text-xs">
                        <li><strong>Autonomy:</strong> Self-sufficiency %</li>
                        <li><strong>Reliability:</strong> Uptime %</li>
                        <li><strong>Environment:</strong> Renewable %</li>
                        <li><strong>Economy:</strong> Profitability</li>
                    </ul>
                </div>

                <div class="rule-section">
                    <div class="rule-title flex items-center gap-2">
                        <i data-lucide="lightbulb" class="w-4 h-4 text-yellow-300"></i>QUICK TIPS
                    </div>
                    <ul class="rule-text list-disc pl-4 space-y-0 text-xs">
                        <li>Solar + Battery combo is reliable</li>
                        <li>Hydro first if rivers available</li>
                        <li>Upgrade early for long-term gains</li>
                        <li>Export surplus for steady income</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- High Score Panel -->
        <div id="highscore-list" class="info-overlay-box hidden mt-8">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-neon-purple font-bold text-xl tracking-widest">FLIGHT RECORDER</h3>
                <button onclick="document.getElementById('highscore-list').classList.add('hidden')" class="text-gray-500 hover:text-white">✕</button>
            </div>
            
            <!-- Tab Navigation -->
            <div class="flex gap-3 mb-4 border-b border-white/10 pb-2">
                <button onclick="game.switchFlightTab('scores')" id="tab-scores" class="px-4 py-2 text-sm font-bold text-neon-cyan border-b-2 border-neon-cyan transition-colors">SCORES</button>
                <button onclick="game.switchFlightTab('analysis')" id="tab-analysis" class="px-4 py-2 text-sm font-bold text-gray-500 hover:text-gray-300 border-b-2 border-transparent transition-colors">ANALYSIS</button>
            </div>
            
            <!-- Scores Tab -->
            <div id="score-entries" class="space-y-2 font-mono text-sm text-gray-300">
                <!-- Injected via JS -->
                <div class="text-center italic text-gray-600">No records found.</div>
            </div>
            
            <!-- Analysis Tab -->
            <div id="analysis-content" class="hidden">
                <!-- Year Selector -->
                <div class="mb-6 flex items-center gap-4">
                    <label class="text-sm font-bold text-gray-400">SELECT YEAR:</label>
                    <select id="year-select" onchange="game.updateAnalysisView()" class="bg-slate-800 border border-cyan-500/50 rounded px-3 py-1 text-sm text-neon-cyan font-mono cursor-pointer">
                        <!-- Options injected by JS -->
                    </select>
                </div>
                
                <!-- Overall Stats Grid -->
                <div id="year-stats" class="grid grid-cols-4 gap-3 mb-6">
                    <div class="bg-slate-800/50 border border-cyan-500/30 rounded p-3">
                        <div class="text-xs text-gray-400 mb-1">FINAL SCORE</div>
                        <div id="stat-score" class="text-2xl font-bold text-neon-cyan">--</div>
                    </div>
                    <div class="bg-slate-800/50 border border-blue-500/30 rounded p-3">
                        <div class="text-xs text-gray-400 mb-1">AVG PRODUCTION</div>
                        <div id="stat-production" class="text-2xl font-bold text-blue-400">0 MWh</div>
                    </div>
                    <div class="bg-slate-800/50 border border-orange-500/30 rounded p-3">
                        <div class="text-xs text-gray-400 mb-1">AVG DEMAND</div>
                        <div id="stat-demand" class="text-2xl font-bold text-orange-400">0 MWh</div>
                    </div>
                    <div class="bg-slate-800/50 border border-green-500/30 rounded p-3">
                        <div class="text-xs text-gray-400 mb-1">RELIABILITY</div>
                        <div id="stat-reliability" class="text-2xl font-bold text-green-400">0%</div>
                    </div>
                </div>
                
                <!-- Key Metrics -->
                <div id="year-metrics" class="grid grid-cols-2 gap-4 mb-6 text-xs">
                    <div class="bg-slate-800/30 border border-white/10 rounded p-3">
                        <div class="text-gray-400 mb-2">ENERGY BREAKDOWN</div>
                        <div id="metrics-breakdown" class="space-y-1 font-mono text-gray-300">
                            <div class="flex justify-between"><span>Solar:</span><span id="m-solar">0%</span></div>
                            <div class="flex justify-between"><span>Wind:</span><span id="m-wind">0%</span></div>
                            <div class="flex justify-between"><span>Hydro:</span><span id="m-hydro">0%</span></div>
                        </div>
                    </div>
                    <div class="bg-slate-800/30 border border-white/10 rounded p-3">
                        <div class="text-gray-400 mb-2">PERFORMANCE</div>
                        <div id="metrics-performance" class="space-y-1 font-mono text-gray-300">
                            <div class="flex justify-between"><span>Months Powered:</span><span id="m-months">0/12</span></div>
                            <div class="flex justify-between"><span>Blackouts:</span><span id="m-blackouts" class="text-red-400">0</span></div>
                            <div class="flex justify-between"><span>Exports:</span><span id="m-exports" class="text-purple-400">0 cr</span></div>
                        </div>
                    </div>
                </div>
                
                <!-- Graph Container -->
                <div class="bg-slate-900/50 border border-slate-700 rounded p-4">
                    <h4 class="text-sm font-bold text-neon-cyan mb-3">MONTHLY DEMAND vs PRODUCTION</h4>
                    <div style="position: relative; height: 300px;">
                        <canvas id="analysis-chart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Storm Overlay -->
    <div id="storm-flash" class="fixed inset-0 bg-white/20 z-50 pointer-events-none opacity-0 transition-opacity duration-200"></div>

    <!-- Tutorial Overlay System -->
    <div id="tutorial-overlay">
        <div class="tutorial-backdrop"></div>
        <div class="tutorial-spotlight" id="tutorial-spotlight"></div>
        <div class="tutorial-box" id="tutorial-box">
            <div class="tutorial-step-indicator" id="step-indicator">Step 1 of 3</div>
            <h2 id="tutorial-title">Welcome to Energy Atlas!</h2>
            <p id="tutorial-text">This interface allows you to build and manage renewable energy infrastructure. Let me show you around.</p>
            <button class="tutorial-button" id="tutorial-next-btn">Next →</button>
        </div>
    </div>

    <!-- Post-Region Game Tutorial Overlay -->
    <div id="game-tutorial-overlay">
        <div class="tutorial-spotlight-game" id="tutorial-spotlight-game"></div>
        <div class="tutorial-box-game" id="tutorial-box-game">
            <div class="tutorial-step-indicator-game" id="tutorial-game-step">Step 1 of 5</div>
            <h2 id="tutorial-game-title">Welcome, Architect!</h2>
            <p id="tutorial-game-text">You've been tasked with managing the energy grid for this region. Let me show you the key elements of your mission.</p>
            <div class="tutorial-buttons">
                <button class="tutorial-button-secondary" id="tutorial-game-skip">Skip Tutorial</button>
                <button class="tutorial-button" id="tutorial-game-next">Next →</button>
            </div>
        </div>
    </div>

    <!-- Region Select Modal -->
    <div id="region-select-modal" class="modal-backdrop hidden">
        <div class="modal-content max-w-4xl">
            <h2 class="text-3xl font-bold text-white digit-font mb-2">SELECT MISSION REGION</h2>
            <div class="w-full h-px bg-white/10 mb-6"></div>
            
            <div id="region-card-container" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <!-- Region cards will be injected here by JavaScript -->
            </div>

            <p class="text-xs text-gray-500 mt-6 italic">Your starting budget and environmental conditions are determined by your choice.</p>
        </div>
    </div>

    <!-- Summary Modal -->
    <div id="summary-modal" class="modal-backdrop">
        <div class="modal-content">
            <h2 class="text-3xl font-bold text-white digit-font mb-2">ANNUAL REPORT</h2>
            <div class="w-full h-px bg-white/10 mb-6"></div>
            
            <div class="grid grid-cols-2 gap-4 mb-6">
                <div class="stat-box">
                    <div class="text-xs text-gray-400 uppercase tracking-widest mb-1">Final Score</div>
                    <div id="summary-score" class="text-4xl text-neon-cyan font-bold digit-font">0</div>
                </div>
                <div class="stat-box">
                    <div class="text-xs text-gray-400 uppercase tracking-widest mb-1">Next Budget</div>
                    <div id="summary-budget" class="text-2xl text-neon-green font-bold digit-font">0</div>
                </div>
            </div>

            <div class="space-y-3 text-left text-sm text-gray-300 mb-8 bg-black/20 p-4 rounded">
                <div class="grid grid-cols-2 gap-y-2 gap-x-4 mb-4 border-b border-white/10 pb-4">
                    <div class="flex justify-between">
                        <span>Autonomy:</span>
                        <span id="summary-autonomy" class="font-bold text-blue-400">0/100</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Reliability:</span>
                        <span id="summary-reliability" class="font-bold text-pink-400">0/100</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Environment:</span>
                        <span id="summary-environment" class="font-bold text-green-400">0/100</span>
                    </div>
                    <div class="flex justify-between">
                        <span>Economy:</span>
                        <span id="summary-economy" class="font-bold text-orange-400">0/100</span>
                    </div>
                </div>

                <div class="flex justify-between">
                    <span>Uptime:</span>
                    <span id="summary-uptime" class="font-bold text-white">0/12 Months</span>
                </div>
                <div class="flex justify-between">
                    <span>Blackouts:</span>
                    <span id="summary-blackouts" class="font-bold text-red-400">0</span>
                </div>
                <div class="flex justify-between border-t border-white/10 pt-2 mt-2">
                    <span>Export Earnings:</span>
                    <span id="summary-exports" class="font-bold text-purple-300">0 cr</span>
                </div>
            </div>

            <button onclick="game.closeSummaryAndNextYear()" class="w-full py-4 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 text-white font-bold text-lg tracking-widest rounded shadow-[0_0_20px_rgba(99,102,241,0.4)] transition-all">
                BEGIN NEXT YEAR
            </button>
        </div>
    </div>

    <!-- Header -->
    <header class="h-20 flex items-center justify-between px-8 z-20 shrink-0 border-b border-white/10 bg-[#0b0c15]/80 backdrop-blur-md">
        <!-- Title & Region Select -->
        <div class="flex items-center gap-6">
            <h1 class="text-3xl text-white font-bold tracking-wider" style="text-shadow: 0 0 15px rgba(0,243,255,0.4);">
                ENERGY ATLAS
            </h1>
            <select id="region-selector" class="region-select hidden" onchange="game.changeRegion(this.value)">
                <!-- Options populated by JS -->
            </select>
        </div>
        
        <!-- Top Right Controls -->
        <div class="flex items-center gap-6">
            <!-- Builders Display -->
            <div class="flex items-center bg-[#1e293b] border border-yellow-500/30 rounded-lg px-4 py-2 shadow-[0_0_10px_rgba(234,179,8,0.1)]">
                <span class="text-gray-400 font-bold mr-3 text-xs tracking-wider">CREWS:</span>
                <span id="builders-display" class="text-xl text-yellow-400 digit-font font-bold">3/3</span>
            </div>

            <!-- Credit Display -->
            <div class="flex items-center bg-[#1e293b] border border-[#00f3ff]/30 rounded-lg px-4 py-2 shadow-[0_0_15px_rgba(0,243,255,0.1)]">
                <span class="text-gray-400 font-bold mr-3 text-xs tracking-wider">CREDIT:</span>
                <span id="budget-display" class="text-2xl text-neon-green digit-font font-bold">10000</span>
                <!-- New Revenue Indicator -->
                <span id="revenue-float" class="ml-2 text-xs text-neon-green font-bold opacity-0 transition-opacity">+0</span>
            </div>

            <!-- Back to Start -->
            <button onclick="game.backToStart()" class="flex items-center gap-2 px-4 py-2 bg-slate-800 border border-slate-600 rounded-lg text-gray-200 font-bold tracking-wider hover:border-neon-cyan hover:text-neon-cyan transition-all">
                <i data-lucide="arrow-left" class="w-4 h-4"></i>
                BACK
            </button>
            
            <!-- Reset Button -->
            <!-- <button onclick="game.reset()" class="bg-[#3f1926] hover:bg-[#5e1b2e] border border-red-500/50 text-red-200 px-6 py-2 rounded-lg font-bold tracking-wider transition-colors shadow-[0_0_10px_rgba(255,0,0,0.2)]">
                RESET
            </button> -->
        </div>
    </header>

    <!-- Main Content Grid -->
    <main class="flex-1 grid grid-cols-12 gap-6 p-6 overflow-hidden z-10">
        
        <!-- LEFT COLUMN: Parameters & Costs (Cols 3) -->
        <aside class="col-span-3 flex flex-col gap-6 overflow-y-auto pr-2">
            
            <!-- Mission Parameters Card -->
            <div class="glass-panel h-auto flex flex-col">
                <div class="glass-panel-header text-neon-pink">MISSION PARAMETERS</div>
                <div class="p-5 space-y-4">
                    
                    <div class="flex justify-between items-center group">
                        <div class="flex items-center gap-3 text-gray-300">
                            <i data-lucide="shield" class="w-4 h-4 text-blue-400"></i>
                            <span class="font-semibold tracking-wide">DEMAND</span>
                        </div>
                        <span id="ui-param-demand" class="text-blue-400 font-mono font-bold">-- MWh</span>
                    </div>

                    <div class="border-t border-white/10 pt-3">
                        <div class="flex items-center gap-2 mb-2">
                            <i data-lucide="zap" class="w-4 h-4 text-yellow-400"></i>
                            <span class="font-semibold tracking-wide text-gray-300 text-sm">REGIONAL YIELDS EFFICIENCY</span>
                        </div>
                        <div class="space-y-2 pl-6">
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="solar-panel" class="w-4 h-4 text-blue-300"></i>
                                    <span class="text-blue-300 text-sm font-semibold">Solar</span>
                                </div>
                                <span id="yield-solar" class="text-blue-400 font-mono font-bold">--</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="fan" class="w-4 h-4 text-pink-300"></i>
                                    <span class="text-pink-300 text-sm font-semibold">Wind</span>
                                </div>
                                <span id="yield-wind" class="text-pink-400 font-mono font-bold">--</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="dam" class="w-4 h-4 text-cyan-300"></i>
                                    <span class="text-cyan-300 text-sm font-semibold">Hydro</span>
                                </div>
                                <span id="yield-hydro" class="text-cyan-400 font-mono font-bold">--</span>
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-between items-center group">
                        <div class="flex items-center gap-3 text-gray-300">
                            <i data-lucide="leaf" class="w-4 h-4 text-green-400"></i>
                            <span class="font-semibold tracking-wide">ECO TARGET</span>
                        </div>
                        <span class="text-green-400 font-mono font-bold">A+</span>
                    </div>

                 
                </div>
            </div>

            <!-- Grid Status Bars Card (Dropdown) -->
            <div class="glass-panel h-auto flex flex-col">
                <button onclick="document.getElementById('grid-status-content').classList.toggle('hidden')" class="glass-panel-header text-neon-green flex justify-between items-center w-full hover:bg-white/10 transition-colors">
                    <span>GRID STATUS</span>
                    <i id="grid-status-icon" data-lucide="chevron-down" class="w-4 h-4"></i>
                </button>
                <div id="grid-status-content" class="p-5 space-y-4">
                    
                    <!-- Building Count Bars -->
                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400">
                            <span>SOLAR</span>
                            <span id="solar-limit" class="text-blue-400">0/10</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-solar" class="bar-fill grad-blue" style="width: 0%"></div>
                        </div>
                    </div>

                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400">
                            <span>WIND</span>
                            <span id="wind-limit" class="text-pink-400">0/10</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-wind" class="bar-fill grad-pink" style="width: 0%"></div>
                        </div>
                    </div>

                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400">
                            <span>HYDRO</span>
                            <span id="hydro-limit" class="text-cyan-400">0/5</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-hydro" class="bar-fill grad-cyan" style="width: 0%"></div>
                        </div>
                    </div>

                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400">
                            <span>BATTERY</span>
                            <span id="battery-limit" class="text-green-400">0/10</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-battery-count" class="bar-fill grad-green" style="width: 0%"></div>
                        </div>
                    </div>

                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400">
                            <span>EXPORT</span>
                            <span id="export-limit" class="text-purple-400">0/2</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-export" class="bar-fill grad-orange" style="width: 0%"></div>
                        </div>
                    </div>

                    <!-- Budget Utilization Bar -->
                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400">
                            <span>BUDGET USAGE</span>
                            <span id="budget-percent" class="text-neon-green">0%</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-budget" class="bar-fill grad-orange" style="width: 0%"></div>
                        </div>
                    </div>

                </div>
            </div>

            <!-- AI Advisor Card -->
            <div class="glass-panel h-auto flex flex-col">
                <div class="glass-panel-header text-cyan-400 flex justify-between items-center">
                    <span>ADVISOR</span>
                    <button onclick="game.getAdvisorTip()" class="px-3 py-1 text-xs bg-cyan-500/20 border border-cyan-500/50 rounded hover:bg-cyan-500/30 transition-colors">
                        GET TIP
                    </button>
                </div>
                <div id="advisor-panel" class="p-5 space-y-3 min-h-[140px] flex flex-col justify-start"></div>
            </div>

            <!-- Construction Cost Card removed per previous request -->

        </aside>

        <!-- CENTER COLUMN: Map & Toolbar (Cols 5) -->
        <section class="col-span-6 flex flex-col items-center justify-center relative gap-6">
            
            <!-- Map Container (2D Wrapper) -->
            <div class="relative w-full max-w-[65vh] aspect-square p-1 rounded-2xl bg-gradient-to-b from-slate-800 to-slate-900 border border-slate-700 shadow-2xl">
                <!-- Sun Icon (Outside/Top) -->
                <div class="absolute -top-12 left-1/2 transform -translate-x-1/2 z-50 pointer-events-none flex flex-col items-center w-28">
                    <div class="w-16 h-16 rounded-full bg-yellow-400 shadow-[0_0_30px_rgba(250,204,21,0.8)] flex items-center justify-center">
                        <i data-lucide="sun" class="w-10 h-10 text-yellow-600"></i>
                    </div>
                    <div class="text-xs text-yellow-400 text-center font-bold mt-1 tracking-widest w-full">BOOSTS SOLAR</div>
                </div>

                <!-- Disaster Notification -->
                <div id="disaster-alert" class="absolute top-4 left-0 right-0 mx-auto w-max px-4 py-1 bg-red-900 border border-red-500 rounded text-red-200 text-xs font-bold tracking-widest uppercase opacity-0 transition-opacity z-30 pointer-events-none">
                    WARNING: STORM SURGE DETECTED
                </div>

                <!-- The 2D Map -->
                <div class="map-container-2d">
                    <div id="game-grid" class="map-grid w-full h-full">
                        <!-- Tiles injected by JS -->
                    </div>
                </div>
            </div>

            <!-- Build Cursor Ghost -->
            <div id="build-cursor" class="build-cursor"></div>
            
            <!-- Tool Info / Message Panel -->
            <div id="tool-info-panel" class="w-full max-w-md bg-[#131620] border border-slate-700 rounded p-3 min-h-[70px] flex flex-col justify-center transition-all z-20">
                <div id="info-title" class="text-neon-cyan font-bold text-xs tracking-[0.2em] mb-1">SYSTEM READY</div>
                <div id="info-body" class="text-gray-400 text-xs leading-relaxed">Select a technology to view specifications and tactical data.</div>
                <div id="info-tip" class="text-gray-500 text-[10px] italic mt-1 border-t border-white/5 pt-1 hidden"></div>
            </div>

        </section>

        <!-- RIGHT COLUMN: Simulation & Results (Cols 3) -->
        <aside class="col-span-3 flex flex-col gap-6">
            <!-- Engine Card -->
            <div class="glass-panel">
                <div class="glass-panel-header text-neon-cyan flex justify-between items-center">
                    <span>SIMULATION ENGINE</span>
                    <i data-lucide="cpu" class="w-4 h-4 opacity-70"></i>
                </div>
                <div class="p-5">
                    <!-- Stats (Always Visible Now) -->
                    <div class="grid grid-cols-2 gap-4 text-center mb-4 border-b border-white/5 pb-4">
                        <div>
                            <div class="text-[10px] text-gray-500 uppercase tracking-widest mb-1">Live Output Per Month</div>
                            <div id="stat-capacity" class="text-xl text-white font-bold digit-font">0 <span class="text-xs text-gray-500 font-sans">MWh</span></div>
                        </div>
                        <div>
                            <div class="text-[10px] text-gray-500 uppercase tracking-widest mb-1">Grid Storage</div>
                            <div class="flex flex-col items-center justify-center h-full">
                                <div class="w-full h-2 bg-slate-800 rounded-full overflow-hidden border border-slate-600">
                                    <div id="battery-bar" class="h-full bg-neon-green transition-all duration-300" style="width: 0%"></div>
                                </div>
                                <div id="stat-battery" class="text-[10px] text-white font-mono mt-1">0 / 0 MWh</div>
                            </div>
                        </div>
                    </div>

                    <!-- Running State Controls (Hidden by default) -->
                    <div id="sim-running-ui" class="hidden flex flex-col gap-3">
                        <div class="flex justify-between items-end border-b border-white/10 pb-2">
                            <div class="text-2xl text-white font-bold digit-font text-neon-orange" id="sim-month">JAN</div>
                            <div class="text-xs text-gray-400 font-mono" id="sim-year-prog">MONTH 1/12</div>
                        </div>

                        <!-- Monthly Target vs Production Bar -->
                        <div>
                            <div class="flex justify-between text-xs mb-1 font-bold text-gray-400">
                                <span>PRODUCTION VS TARGET</span>
                                <span id="prod-status" class="text-neon-cyan">0 / 0 MWh</span>
                            </div>
                            <div class="bar-container">
                                <div id="bar-production" class="bar-fill grad-blue" style="width: 0%"></div>
                            </div>
                        </div>
                        
                        <!-- Speed Slider -->
                        <div class="flex flex-col gap-2">
                            <div class="flex justify-between items-center text-xs font-bold text-gray-400">
                                <span>SIMULATION SPEED</span>
                                <span id="speed-display" class="text-neon-orange">1x</span>
                            </div>
                            <input type="range" id="speed-slider" min="1" max="100" value="1" class="w-full cursor-pointer" style="height: 6px; accent-color: #00f3ff;">
                        </div>
                    </div>

                    <!-- Pre-Simulation Predictions (Hidden during sim) -->
                    <div id="sim-predictions" class="flex flex-col gap-3">
                        <div class="bg-slate-800/30 border border-slate-700 rounded p-3">
                            <div class="text-xs font-bold text-gray-400 mb-2">PREDICTED PERFORMANCE</div>
                            
                            <div class="space-y-2 text-xs">
                                <div class="flex justify-between">
                                    <span class="text-gray-400">Total Capacity:</span>
                                    <span id="pred-capacity" class="text-neon-cyan font-mono">0 MWh/mo</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-400">Avg Monthly Demand:</span>
                                    <span id="pred-demand" class="text-neon-orange font-mono">0 MWh/mo</span>
                                </div>
                                <div class="flex justify-between border-t border-slate-700 pt-2 mt-2">
                                    <span class="text-gray-400 font-bold">Est. Months Powered:</span>
                                    <span id="pred-months" class="text-neon-green font-bold font-mono">0 / 12</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Placeholder to keep height consistent when sim-running-ui is hidden (Optional, but nice) -->
                    <div id="sim-placeholder" class="h-2 text-center text-[10px] text-gray-600 italic">
                        System Standby
                    </div>
                
                </div>
            </div>

            <!-- Build Menu Dropdown -->
            <div class="glass-panel">
                <div class="glass-panel-header text-neon-cyan flex justify-between items-center w-full">
                    <button onclick="game.toggleBuildMenu()" class="flex items-center gap-2 hover:text-white transition-colors">
                        <span>BUILD MENU</span>
                        <i data-lucide="chevron-down" class="w-4 h-4 opacity-70"></i>
                    </button>
                    <button onclick="game.buyUpgrade()" id="btn-upgrade" class="flex items-center gap-2 px-2 py-1 text-[10px] bg-purple-900/30 border border-purple-500/40 rounded hover:border-purple-300 hover:text-purple-200 transition-colors">
                        <i data-lucide="zap" class="w-4 h-4 text-purple-300"></i>
                        <span id="upgrade-text" class="font-bold">UPGRADE</span>
                        <span id="upgrade-count" class="font-mono text-gray-400">0/15</span>
                    </button>
                </div>
                <div id="build-menu-content" class="p-3 grid grid-cols-3 gap-3 w-full">
                    <button onclick="game.selectTool('solar')" id="btn-solar" class="tech-btn w-full h-20 flex flex-col items-center justify-center group">
                        <i data-lucide="solar-panel" class="w-9 h-9 text-blue-300 mb-1 group-hover:text-white transition-colors"></i>
                        <span class="text-[10px] font-bold text-gray-400 tracking-wider group-hover:text-neon-cyan">SOLAR</span>
                        <span class="text-[9px] text-yellow-400">450cr</span>
                        <span id="limit-solar" class="text-[9px] text-gray-600 font-mono">--/--</span>
                    </button>

                    <button onclick="game.selectTool('wind')" id="btn-wind" class="tech-btn w-full h-20 flex flex-col items-center justify-center group">
                        <i data-lucide="fan" class="w-9 h-9 text-pink-300 mb-1 group-hover:text-white transition-colors"></i>
                        <span class="text-[10px] font-bold text-gray-400 tracking-wider group-hover:text-neon-pink">WIND</span>
                        <span class="text-[9px] text-yellow-400">700cr</span>
                        <span id="limit-wind" class="text-[9px] text-gray-600 font-mono">--/--</span>
                    </button>

                    <button onclick="game.selectTool('hydro')" id="btn-hydro" class="tech-btn w-full h-20 flex flex-col items-center justify-center group">
                        <i data-lucide="dam" class="w-9 h-9 text-cyan-300 mb-1 group-hover:text-white transition-colors"></i>
                        <span class="text-[10px] font-bold text-gray-400 tracking-wider group-hover:text-white">HYDRO</span>
                        <span class="text-[9px] text-yellow-400">600cr</span>
                        <span id="limit-hydro" class="text-[9px] text-gray-600 font-mono">--/--</span>
                    </button>

                    <button onclick="game.selectTool('battery')" id="btn-battery" class="tech-btn w-full h-20 flex flex-col items-center justify-center group">
                        <i data-lucide="battery-charging" class="w-9 h-9 text-green-400 mb-1 group-hover:text-white transition-colors"></i>
                        <span class="text-[10px] font-bold text-gray-400 tracking-wider group-hover:text-neon-green">BATTERY</span>
                        <span class="text-[9px] text-yellow-400">200cr</span>
                        <span id="limit-battery" class="text-[9px] text-gray-600 font-mono">--/--</span>
                    </button>

                    <button onclick="game.selectTool('bulldoze')" id="btn-bulldoze" class="tech-btn w-full h-20 flex flex-col items-center justify-center group border-red-500/30">
                        <i data-lucide="trash-2" class="w-9 h-9 text-red-400 mb-1 group-hover:text-white transition-colors"></i>
                        <span class="text-[10px] font-bold text-gray-400 tracking-wider group-hover:text-red-400">BULLDOZE</span>
                        <span class="text-[9px] text-gray-500">50% REF</span>
                    </button>

                    <button onclick="game.selectTool('export')" id="btn-export" class="tech-btn w-full h-20 flex flex-col items-center justify-center group">
                        <i data-lucide="circle-dollar-sign" class="w-9 h-9 text-purple-400 mb-1 group-hover:text-white transition-colors"></i>
                        <span class="text-[10px] font-bold text-gray-400 tracking-wider group-hover:text-purple-300">EXPORT</span>
                        <span class="text-[9px] text-yellow-400">1200cr</span>
                        <span id="limit-export" class="text-[9px] text-gray-600 font-mono">--/--</span>
                    </button>
                </div>
            </div>

            <!-- Results Card -->
            <div id="results-container" class="glass-panel flex-1 flex flex-col hidden">
                <div class="glass-panel-header text-gray-300">RESULTS</div>
                
                <div id="results-panel" class="p-5 flex-1 flex flex-col gap-4">
                    
                    <!-- Autonomy Bar -->
                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400 tracking-wide">
                            <span>AUTONOMY</span><span id="score-autonomy" class="text-blue-400">0%</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-autonomy" class="bar-fill grad-blue w-0"></div>
                        </div>
                    </div>

                    <!-- Reliability Bar -->
                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400 tracking-wide">
                            <span>RELIABILITY</span><span id="score-reliability" class="text-pink-400">0%</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-reliability" class="bar-fill grad-pink w-0"></div>
                        </div>
                    </div>

                    <!-- Environment Bar -->
                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400 tracking-wide">
                            <span>ENVIRONMENT</span><span id="score-env" class="text-green-400">0%</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-env" class="bar-fill grad-green w-0"></div>
                        </div>
                    </div>

                    <!-- Cost Bar -->
                    <div>
                        <div class="flex justify-between text-xs mb-1 font-bold text-gray-400 tracking-wide">
                            <span>ECONOMIC SCORE</span><span id="score-cost" class="text-orange-400">0%</span>
                        </div>
                        <div class="bar-container">
                            <div id="bar-cost" class="bar-fill grad-orange w-0"></div>
                        </div>
                    </div>

                    <!-- Final Score Display -->
                    <div class="mt-auto pt-6 text-center">
                        <div class="text-[10px] uppercase tracking-[0.3em] text-gray-500 mb-2">Final Evaluation</div>
                        <div class="text-5xl font-bold text-white digit-font glow-text" id="final-score" style="text-shadow: 0 0 20px rgba(255,255,255,0.3);">
                            --
                        </div>
                    </div>
                </div>
            </div>

            <!-- Bottom Panel: Analysis/Button -->
            <div class="glass-panel p-4 flex flex-col gap-3">
                 <div id="analysis-text" class="text-[11px] leading-relaxed text-gray-400 font-mono min-h-[40px] italic">
                    Ready to initialize simulation sequence...
                </div>

                <button id="btn-run" onclick="game.toggleSimulation()" class="w-full py-3 rounded-lg bg-gradient-to-r from-blue-600 to-indigo-600 border border-blue-400 text-white font-bold tracking-widest uppercase hover:shadow-[0_0_20px_rgba(59,130,246,0.5)] transition-all transform hover:-translate-y-1">
                    Run Simulation
                </button>
            </div>

        </aside>

    </main>

    <script>
        // --- DATA ---
        const REGIONS = {
            atlantic: {
                name: "Atlantic Village",
                solarYield: 0.65,
                windYield: 0.55,
                hydroYield: 0.20,
                population: 3000,
                baselineDemandKWh: 7500, 
                budget: 10000,
                desc: "Moderate climate. Balanced renewable options."
            },
            desert: {
                name: "Sunrise Desert",
                solarYield: 0.90,
                windYield: 0.25,
                hydroYield: 0.05,
                population: 2800,
                baselineDemandKWh: 9000, 
                budget: 12000,
                desc: "High solar potential. Water scarcity limits hydro."
            },
            fjord: {
                name: "North Fjord",
                solarYield: 0.35,
                windYield: 0.50,
                hydroYield: 0.80,
                population: 3200,
                baselineDemandKWh: 7000, 
                budget: 15000,
                desc: "Low solar. Excellent hydro potential due to terrain."
            },
            plains: {
                name: "Windy Plains",
                solarYield: 0.55,
                windYield: 0.80,
                hydroYield: 0.10,
                population: 4100,
                baselineDemandKWh: 6500, 
                budget: 8500,
                desc: "Strong, consistent winds. Flat terrain."
            }
        };

        const MONTHS = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
        
        const SEASONALITY = {
            solar: [0.6, 0.7, 0.9, 1.1, 1.25, 1.3, 1.3, 1.2, 1.0, 0.8, 0.6, 0.5], 
            wind:  [1.2, 1.1, 1.1, 1.0, 0.8, 0.7, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2], 
            hydro: [0.8, 0.8, 1.0, 1.3, 1.2, 1.0, 0.9, 0.8, 0.8, 0.9, 1.0, 0.9], 
            battery: Array(12).fill(1.0) 
        };

        const FARMER_AVATARS = [
            'farmer/farmer1.png',
            'farmer/farmer2.png',
            'farmer/farmer3.png',
            'farmer/farmer4.png',
            'farmer/farmer5.png'
        ];

        // New: Demand Curve (1.0 = Baseline)
        const DEMAND_CURVE = [1.2, 1.1, 1.0, 0.9, 0.95, 1.1, 1.3, 1.2, 1.0, 0.9, 1.1, 1.25];

        // --- TOOL INFO DATA ---
        const TOOL_INFO = {
            solar: { 
                title: "SOLAR ARRAY", 
                desc: "Generates power during the day. Output peaks in Summer.", 
                tip: "Intermittent: 50% of output is lost ('Night Mode') unless captured by Batteries." 
            },
            wind: { 
                title: "WIND TURBINE", 
                desc: "High output generator. Performance varies significantly by season.", 
                tip: "NOISY! Placing within 1 tile of Town reduces reliability & budget." 
            },
            hydro: { 
                title: "HYDRO PLANT", 
                desc: "Consistent, high-yield power. Requires River terrain.", 
                tip: "Resilient against Cloud Cover events." 
            },
            battery: { 
                title: "LITHIUM STORAGE", 
                desc: "Stores excess energy to stabilize grid reliability.", 
                tip: "REQUIRED to capture the 50% 'Night' output from Solar panels." 
            },
            export: { 
                title: "EXPORT HUB", 
                desc: "Connects local grid to the main network.", 
                tip: "Automatically sells surplus power for 0.3 Credits/MWh." 
            },
            bulldoze: { 
                title: "DEMOLITION CREW", 
                desc: "Clears land for new construction.", 
                tip: "Refunds 50% of the initial construction cost." 
            },
            upgrade: {
                title: "GRID EFFICIENCY",
                desc: "Improves output of all existing and future units.",
                tip: "Stackable up to 5 times (+15% Max)."
            }
        };

        // --- GAME CONFIGURATION ---
        let CONFIG = {
            budget: 10000,
            demand: 7500, 
            gridSize: 8,
            weather: { solar: 0.65, wind: 0.55, hydro: 0.20 },
            buildings: {
                // REBALANCED OUTPUTS (Monthly Base)
                // Costs reduced for affordability
                solar:   { cost: 450,  output: 65,   reliability: 0.4, type: 'land',  env: 9 }, 
                wind:    { cost: 700,  output: 90,   reliability: 0.6, type: 'land',  env: 8 }, 
                hydro:   { cost: 600,  output: 120,  reliability: 0.9, type: 'river', env: 7 }, 
                battery: { cost: 200,  output: 0,    capacity: 150,    type: 'land',  env: 8 }, 
                export:  { cost: 1200, output: 0,    reliability: 0.0, type: 'land',  env: 8 } 
            },
            upgrade: { cost: 400, multiplierPerLevel: 0.03, maxLevel: 5 },
            baseMonthDuration: 20000, 
            gracePeriodDuration: 10, 
            exportRate: 0.3,
            noiseFine: 50,
            maxBuilders: 3,
            constructionTime: 2, 
            demandGrowth: 0.02,
            repairCost: 150, 
            repairTime: 3    
        };

        // --- GAME STATE ---
        const game = {
            // ... existing state ...
            audio: {
                bg: null,
                success: null,
                fail: null,
                build: null,
                destroy: null
            },
            grid: [],
            budget: CONFIG.budget,
            selectedTool: null,
            upgradeLevel: 0,
            currentRegion: 'atlantic',
            
            // Limits State
            limits: {},
            
            // Build State
            activeBuilders: 0,
            
            // Simulation State
            isSimulating: false,
            inGracePeriod: false, 
            graceTimerVal: 0,
            simMonth: 0,
            speedMultiplier: 1,
            simTimer: null,
            simResults: { production: 0, monthsPowered: 0, envSum: 0, totalDemandSoFar: 0, exportEarnings: 0 }, 
            activeEvents: [],
            
            // Battery State
            batteryCharge: 0,
            maxBatteryCapacity: 0,

            // Town Data
            townIndices: [27, 28, 35, 36], // Center 2x2
            townPowered: true, // Live status
            
            // Monthly History for Analysis
            monthlyHistory: [],

            // UI Elements
            buildCursorEl: null,
            isGridHover: false,
            farmerAvatar: null,
            analysisChart: null,
            currentFlightTab: 'scores',

            init() {
                this.audio.bg = document.getElementById('bg-music');
                this.audio.success = document.getElementById('sound-success');
                this.audio.fail = document.getElementById('sound-fail');
                this.audio.build = document.getElementById('sound-build');
                this.audio.destroy = document.getElementById('sound-destroy');
                this.audio.bg.volume = 0.15; // Set a low volume for background music

                this.buildCursorEl = document.getElementById('build-cursor');
                window.addEventListener('mousemove', (e) => this.moveBuildCursor(e));
                window.addEventListener('mouseleave', () => this.hideBuildCursor());

                
                this.initRegionSelector();
                this.setAdvisorIdleMessage();
                // DO NOT call loadRegion here to prevent auto-setup before start screen
                // Just render empty grid or wait
                // loadRegion('atlantic'); // Moved to dismissStartScreen
                
                // But we need lucide for the start screen if any
                lucide.createIcons();
            },

            dismissStartScreen() {
                document.getElementById('start-screen').style.opacity = 0;
                setTimeout(() => {
                    document.getElementById('start-screen').style.display = 'none';
                    this.showRegionModal();
                }, 500);
            },

            showRegionModal() {
                const modal = document.getElementById('region-select-modal');
                const container = document.getElementById('region-card-container');
                container.innerHTML = ''; // Clear previous cards

                const difficultyMap = {
                    atlantic: { label: 'MEDIUM', cls: 'text-yellow-400' },
                    desert:   { label: 'EASY', cls: 'text-green-400' },
                    fjord:    { label: 'EASY', cls: 'text-green-400' },
                    plains:   { label: 'HARD', cls: 'text-red-400' }
                };

                Object.keys(REGIONS).forEach(key => {
                    const region = REGIONS[key];
                    const diff = difficultyMap[key] || { label: 'NORMAL', cls: 'text-gray-400' };
                    const card = document.createElement('div');
                    card.className = 'region-card';
                    card.onclick = () => this.selectAndStart(key);

                    const yields = `Solar:${Math.round(region.solarYield*100)}% Wind:${Math.round(region.windYield*100)}% Hydro:${Math.round(region.hydroYield*100)}%`;

                    card.innerHTML = `
                        <h3 class="text-xl font-bold text-neon-cyan digit-font mb-2">${region.name.toUpperCase()}</h3>
                        <p class="text-xs text-gray-400 italic mb-4">${region.desc}</p>
                        <div class="border-t border-white/10 pt-3 space-y-2 text-xs">

                            <div class="flex justify-between"><span>STARTING BUDGET:</span> <span class="font-bold text-neon-green">${region.budget.toLocaleString()} cr</span></div>
                            <div class="flex justify-between"><span>YIELDS:</span> <span class="font-bold text-pink-300">${yields}</span></div>
                            <div class="flex justify-between"><span>BASELINE DEMAND:</span> <span class="font-bold text-neon-orange">${region.baselineDemandKWh.toLocaleString()} MWh/mo</span></div>
                            <div class="flex justify-between"><span>DIFFICULTY:</span> <span class="font-bold ${diff.cls}">${diff.label}</span></div>
                        
                        </div>
                    `;
                    container.appendChild(card);
                });

                modal.classList.remove('hidden');
                requestAnimationFrame(() => modal.classList.add('visible'));
            },

            selectAndStart(regionKey) {
                const modal = document.getElementById('region-select-modal');
                modal.classList.remove('visible');
                setTimeout(() => modal.classList.add('hidden'), 300);

                this.loadRegion(regionKey);
                this.audio.bg.play().catch(e => console.log("Autoplay blocked"));
                
                // Start game tutorial after a short delay for UI settling
                setTimeout(() => this.startGameTutorial(), 800);
            },

            toggleRules() {
                const rules = document.getElementById('rules-list');
                const scores = document.getElementById('highscore-list');
                
                scores.classList.add('hidden'); // Close scores if open
                
                if (rules.classList.contains('hidden')) {
                    rules.classList.remove('hidden');
                } else {
                    rules.classList.add('hidden');
                }
            },

            toggleHighScores() {
                const list = document.getElementById('highscore-list');
                const rules = document.getElementById('rules-list');
                
                rules.classList.add('hidden'); // Close rules if open

                if (list.classList.contains('hidden')) {
                    list.classList.remove('hidden');
                    this.currentFlightTab = 'scores';
                    this.switchFlightTab('scores');
                } else {
                    list.classList.add('hidden');
                }
            },
            
            switchFlightTab(tab) {
                this.currentFlightTab = tab;
                const scoreEl = document.getElementById('score-entries');
                const analysisEl = document.getElementById('analysis-content');
                const tabScores = document.getElementById('tab-scores');
                const tabAnalysis = document.getElementById('tab-analysis');
                
                if (tab === 'scores') {
                    scoreEl.classList.remove('hidden');
                    analysisEl.classList.add('hidden');
                    tabScores.classList.add('border-b-2', 'border-neon-cyan', 'text-neon-cyan');
                    tabScores.classList.remove('border-transparent', 'text-gray-500');
                    tabAnalysis.classList.add('border-transparent', 'text-gray-500');
                    tabAnalysis.classList.remove('border-b-2', 'border-neon-cyan', 'text-neon-cyan');
                    this.loadScoresTab();
                } else {
                    scoreEl.classList.add('hidden');
                    analysisEl.classList.remove('hidden');
                    tabAnalysis.classList.add('border-b-2', 'border-neon-cyan', 'text-neon-cyan');
                    tabAnalysis.classList.remove('border-transparent', 'text-gray-500');
                    tabScores.classList.add('border-transparent', 'text-gray-500');
                    tabScores.classList.remove('border-b-2', 'border-neon-cyan', 'text-neon-cyan');
                    this.loadAnalysisTab();
                }
            },
            
            loadScoresTab() {
                const entries = document.getElementById('score-entries');
                const scores = JSON.parse(localStorage.getItem('energyGameScores')) || [];
                scores.sort((a, b) => b.score - a.score);
                
                if (scores.length === 0) {
                    entries.innerHTML = '<div class="text-center italic text-gray-600">No records found.</div>';
                } else {
                    entries.innerHTML = scores.slice(0, 10).map((s, i) => `
                        <div class="flex justify-between border-b border-white/5 pb-2 mb-2">
                            <div>
                                <div class="text-neon-cyan font-bold">#${i+1} ${s.region.toUpperCase()}</div>
                                <div class="text-xs text-gray-500">${s.date}</div>
                            </div>
                            <div class="text-right">
                                <div class="text-white font-bold text-lg">${s.score.toLocaleString()}</div>
                                <div class="text-xs text-neon-purple">SCORE</div>
                            </div>
                        </div>
                    `).join('');
                }
            },
            
            loadAnalysisTab() {
                const gameHistory = JSON.parse(localStorage.getItem('gameHistory')) || [];
                const yearSelect = document.getElementById('year-select');
                
                if (gameHistory.length === 0) {
                    yearSelect.innerHTML = '<option value="">No data available</option>';
                    return;
                }
                
                yearSelect.innerHTML = gameHistory.map((year, idx) => `
                    <option value="${idx}">${year.region} - ${year.date}</option>
                `).join('');
                
                this.updateAnalysisView();
            },
            
            updateAnalysisView() {
                const gameHistory = JSON.parse(localStorage.getItem('gameHistory')) || [];
                const yearSelect = document.getElementById('year-select');
                const selectedIdx = parseInt(yearSelect.value);
                
                if (selectedIdx < 0 || selectedIdx >= gameHistory.length) return;
                
                const yearData = gameHistory[selectedIdx];
                
                // Update stats
                document.getElementById('stat-score').innerText = yearData.score.toLocaleString();
                document.getElementById('stat-production').innerText = `${yearData.avgProduction} MWh`;
                document.getElementById('stat-demand').innerText = `${yearData.demand} MWh`;
                document.getElementById('stat-reliability').innerText = `${Math.round((yearData.monthsPowered / 12) * 100)}%`;
                
                // Update metrics
                document.getElementById('m-solar').innerText = `${yearData.energyMix.solar}%`;
                document.getElementById('m-wind').innerText = `${yearData.energyMix.wind}%`;
                document.getElementById('m-hydro').innerText = `${yearData.energyMix.hydro}%`;
                document.getElementById('m-months').innerText = `${yearData.monthsPowered}/12`;
                document.getElementById('m-blackouts').innerText = `${yearData.blackouts}`;
                document.getElementById('m-exports').innerText = `${yearData.exportEarnings.toLocaleString()} cr`;
                
                // Draw chart
                this.drawAnalysisChart(yearData);
            },
            
            drawAnalysisChart(yearData) {
                const ctx = document.getElementById('analysis-chart');
                if (!ctx) return;
                
                // Prepare data with monthly history
                const months = MONTHS;
                let demandData = [];
                let productionData = [];
                
                if (yearData.monthlyData && yearData.monthlyData.length > 0) {
                    demandData = yearData.monthlyData.map(m => m.demand || yearData.demand);
                    productionData = yearData.monthlyData.map(m => m.production || 0);
                } else {
                    // Generate estimated data based on yearly average
                    demandData = months.map((_, i) => Math.round(yearData.demand * (0.9 + Math.random() * 0.2)));
                    productionData = months.map((_, i) => Math.round(yearData.avgProduction * (0.8 + Math.random() * 0.4)));
                }
                
                // Destroy old chart if exists
                if (this.analysisChart) {
                    this.analysisChart.destroy();
                }
                
                this.analysisChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: months,
                        datasets: [
                            {
                                label: 'Demand (MWh)',
                                data: demandData,
                                borderColor: '#ff9d00',
                                backgroundColor: 'rgba(255, 157, 0, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 4,
                                pointBackgroundColor: '#ff9d00'
                            },
                            {
                                label: 'Production (MWh)',
                                data: productionData,
                                borderColor: '#00f3ff',
                                backgroundColor: 'rgba(0, 243, 255, 0.1)',
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 4,
                                pointBackgroundColor: '#00f3ff'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: '#cbd5e1',
                                    font: { size: 12, weight: 'bold' },
                                    padding: 15
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(15, 23, 42, 0.9)',
                                titleColor: '#fff',
                                bodyColor: '#cbd5e1',
                                borderColor: 'rgba(0, 243, 255, 0.3)',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            y: {
                                display: true,
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#94a3b8', font: { size: 11 } }
                            },
                            x: {
                                display: true,
                                grid: { color: 'rgba(255, 255, 255, 0.05)' },
                                ticks: { color: '#94a3b8', font: { size: 11 } }
                            }
                        }
                    }
                });
            },

            saveScore(score) {
                const scores = JSON.parse(localStorage.getItem('energyGameScores')) || [];
                const gameHistory = JSON.parse(localStorage.getItem('gameHistory')) || [];
                
                // Calculate game statistics from current state
                const breakdown = this.getBuildingBreakdown();
                const totalBuildings = Object.values(breakdown).reduce((a, b) => a + b, 0);
                let energyMix = { solar: 0, wind: 0, hydro: 0 };
                if (totalBuildings > 0) {
                    energyMix.solar = Math.round((breakdown.solar / totalBuildings) * 100);
                    energyMix.wind = Math.round((breakdown.wind / totalBuildings) * 100);
                    energyMix.hydro = Math.round((breakdown.hydro / totalBuildings) * 100);
                }
                
                const yearData = {
                    score: Math.floor(score),
                    region: this.currentRegion,
                    date: new Date().toLocaleDateString(),
                    monthsPowered: this.simResults.monthsPowered || 0,
                    blackouts: 12 - (this.simResults.monthsPowered || 0),
                    exportEarnings: Math.floor(this.simResults.exportEarnings || 0),
                    avgProduction: this.getAverageProduction(),
                    demand: CONFIG.demand,
                    energyMix: energyMix,
                    monthlyData: this.monthlyHistory || [],
                    buildingCounts: breakdown,
                    upgradeLevel: this.upgradeLevel
                };
                
                scores.push({
                    score: Math.floor(score),
                    region: this.currentRegion,
                    date: new Date().toLocaleDateString()
                });
                
                gameHistory.push(yearData);
                
                localStorage.setItem('energyGameScores', JSON.stringify(scores));
                localStorage.setItem('gameHistory', JSON.stringify(gameHistory));
            },

            initRegionSelector() {
                const sel = document.getElementById('region-selector');
                Object.keys(REGIONS).forEach(key => {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.innerText = REGIONS[key].name.toUpperCase();
                    sel.appendChild(opt);
                });
            },

            changeRegion(regionKey) {
                this.currentRegion = regionKey;
                // Only reload if not in start screen mode (start screen active means game hasn't started)
                if (document.getElementById('start-screen').style.display === 'none') {
                    this.loadRegion(regionKey);
                }
            },

            loadRegion(regionKey) {
                this.stopSimulation(); 
                this.currentRegion = regionKey;
                const data = REGIONS[regionKey];

                // Set the background image based on the region
                document.body.style.backgroundImage = `url('backgrounds/${regionKey}.jpg')`;


                CONFIG.weather.solar = data.solarYield;
                CONFIG.weather.wind = data.windYield;
                CONFIG.weather.hydro = data.hydroYield;
                CONFIG.demand = data.baselineDemandKWh;
                CONFIG.budget = data.budget;
                REGIONS[regionKey].demand = CONFIG.demand;

                // Generate Random Logical Limits based on Region
                this.generateLimits(regionKey);

                document.getElementById('ui-param-demand').innerText = `${data.baselineDemandKWh.toLocaleString()} MWh`;
                
                // Update yields display
                document.getElementById('yield-solar').innerText = `${Math.round(data.solarYield * 100)}%`;
                document.getElementById('yield-wind').innerText = `${Math.round(data.windYield * 100)}%`;
                document.getElementById('yield-hydro').innerText = `${Math.round(data.hydroYield * 100)}%`;

                this.reset();
            },

            generateLimits(region) {
                // Helper for range
                const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
                
                let l = {
                    solar: 10,
                    wind: 10,
                    hydro: 5,
                    battery: 10,
                    export: 2
                };

                if (region === 'atlantic') {
                    l.solar = rand(10, 14);
                    l.wind = rand(10, 14);
                    l.hydro = rand(3, 6);
                    l.battery = rand(8, 12);
                } else if (region === 'desert') {
                    l.solar = rand(18, 25);
                    l.wind = rand(4, 8);
                    l.hydro = rand(0, 2); 
                    l.battery = rand(12, 16); 
                } else if (region === 'fjord') {
                    l.solar = rand(4, 8);
                    l.wind = rand(12, 18);
                    l.hydro = rand(6, 10);
                    l.battery = rand(6, 10);
                } else if (region === 'plains') {
                    l.solar = rand(8, 12);
                    l.wind = rand(15, 22);
                    l.hydro = rand(2, 4);
                    l.battery = rand(8, 12);
                }
                
                l.export = rand(1, 3); 
                this.limits = l;
            },

            reset() {
                // Stop any end-game sounds from playing over the reset
                this.audio.success.pause(); this.audio.success.currentTime = 0;
                this.audio.fail.pause(); this.audio.fail.currentTime = 0;

                this.stopSimulation();
                this.budget = CONFIG.budget;
                this.upgradeLevel = 0;
                this.selectedTool = null;
                this.updateBuildCursor();
                this.activeEvents = [];
                this.activeBuilders = 0;
                this.hideDisasterAlert();
                this.generateTerrain();
                this.renderGrid();
                this.updateUI();
                this.updatePredictions();
                
                // Ensure Results Panel is hidden on reset
                document.getElementById('results-container').classList.add('hidden');
                document.getElementById('sim-predictions').classList.remove('hidden');

                const btn = document.getElementById('btn-upgrade');
                btn.classList.remove('opacity-50', 'pointer-events-none');
                btn.innerHTML = `
                    <i data-lucide="zap" class="w-8 h-8 text-purple-400 mb-1 group-hover:text-white transition-colors"></i>
                    <span id="upgrade-text" class="text-[10px] font-bold text-gray-400 tracking-wider group-hover:text-neon-purple">UPGRADE</span>
                    <span id="upgrade-count" class="text-[9px] text-gray-600 font-mono mt-0.5">0/15</span>
                `;
                document.getElementById('final-score').innerText = "--";
                document.getElementById('analysis-text').innerText = "Place and upgrade your energy infrastructure, then run the simulation to see how well you meet the town's demand.";
                
                ['autonomy', 'reliability', 'env', 'cost'].forEach(k => {
                    document.getElementById(`bar-${k}`).style.width = '0%';
                    document.getElementById(`score-${k}`).innerText = '0%';
                });

                // Restore the run button's default state and action
                const btnRun = document.getElementById('btn-run');
                btnRun.innerText = "Run Simulation";
                btnRun.onclick = () => game.toggleSimulation();
                btnRun.className = "w-full py-3 rounded-lg bg-gradient-to-r from-blue-600 to-indigo-600 border border-blue-400 text-white font-bold tracking-widest uppercase hover:shadow-[0_0_20px_rgba(59,130,246,0.5)] transition-all transform hover:-translate-y-1";

                document.querySelectorAll('.tech-btn').forEach(b => b.classList.remove('selected'));
                lucide.createIcons();
            },

            generateTerrain() {
                this.grid = Array(64).fill(null).map((_, i) => {
                    const windSpeed = 0.8 + Math.random() * 0.4; // Random between 0.8 and 1.2
                    const sunCoverage = 0.8 + Math.random() * 0.4; // Random between 0.8 and 1.2
                    return {
                        id: i,
                        type: 'land',
                        building: null,
                        disasterEffect: null,
                        isConstruction: false,
                        isBroken: false, // Added broken state
                        windSpeed: windSpeed,
                        sunCoverage: sunCoverage
                    };
                });

                // Generate two 2x2 cities at random locations
                this.townIndices = [];
                
                // First city
                const city1Row = Math.floor(Math.random() * 6);
                const city1Col = Math.floor(Math.random() * 6);
                for (let r = 0; r < 2; r++) {
                    for (let c = 0; c < 2; c++) {
                        const idx = (city1Row + r) * 8 + (city1Col + c);
                        this.townIndices.push(idx);
                    }
                }
                
                // Second city (ensure it doesn't overlap with first)
                let city2Row, city2Col, overlap;
                do {
                    overlap = false;
                    city2Row = Math.floor(Math.random() * 6);
                    city2Col = Math.floor(Math.random() * 6);
                    
                    // Check for overlap with first city
                    for (let r = 0; r < 2; r++) {
                        for (let c = 0; c < 2; c++) {
                            const idx = (city2Row + r) * 8 + (city2Col + c);
                            if (this.townIndices.includes(idx)) {
                                overlap = true;
                            }
                        }
                    }
                } while (overlap);
                
                // Add second city
                for (let r = 0; r < 2; r++) {
                    for (let c = 0; c < 2; c++) {
                        const idx = (city2Row + r) * 8 + (city2Col + c);
                        this.townIndices.push(idx);
                    }
                }

                // Generate river: bias vertical flow with light meanders
                const riverRows = this.currentRegion === 'desert' ? 5 : 8;
                let currentCol = Math.floor(Math.random() * 8);
                const bendChance = 0.25;
                
                for (let row = 0; row < riverRows; row++) {
                    const idx = row * 8 + currentCol;
                    this.grid[idx].type = 'river';
                    
                    if (Math.random() < bendChance) {
                        const dir = Math.random() < 0.5 ? -1 : 1;
                        const nextCol = Math.min(7, Math.max(0, currentCol + dir));
                        if (nextCol !== currentCol) {
                            const bendIdx = row * 8 + nextCol;
                            this.grid[bendIdx].type = 'river';
                            currentCol = nextCol;
                        }
                    }
                }

                // Add trees (~15% of land tiles)
                for (let i = 0; i < 64; i++) {
                    if (this.grid[i].type === 'land' && !this.townIndices.includes(i)) {
                        if (Math.random() < 0.15) {
                            this.grid[i].type = 'forest';
                        }
                    }
                }

                // Add mountains (~10% of remaining land tiles)
                for (let i = 0; i < 64; i++) {
                    if (this.grid[i].type === 'land' && !this.townIndices.includes(i)) {
                        if (Math.random() < 0.10) {
                            this.grid[i].type = 'mountain';
                        }
                    }
                }

                // Enforce Town Center
                this.townIndices.forEach(idx => {
                    this.grid[idx].type = 'town';
                    this.grid[idx].building = 'town'; 
                });

            },

            renderGrid() {
                const container = document.getElementById('game-grid');
                container.innerHTML = '';
                container.onmouseenter = () => {
                    this.isGridHover = true;
                    this.updateBuildCursor();
                };

                this.grid.forEach((tile, index) => {
                    const div = document.createElement('div');
                    let classes = `tile`;
                    
                    // Style prioritization
                    if (tile.isConstruction) classes += ' tile-construction';
                    else if (tile.isBroken) classes += ' tile-broken';
                    else if (tile.type === 'town') {
                        classes += ' tile-town';
                        if (!this.townPowered) classes += ' tile-town-off'; 
                    }
                    else if (tile.type === 'river') classes += ' tile-river';
                    else if (tile.type === 'forest') classes += ' tile-forest';
                    else if (tile.type === 'mountain') classes += ' tile-mountain';
                    else classes += ' tile-land';
                    
                    // Add sun boost visual indicator for land tiles
                    if (tile.type === 'land' && !tile.building && !tile.isConstruction) {
                        const boost = this.getSunBoost(index);
                        if (boost > 1.0) {
                            classes += ' sun-boosted';
                        }
                    }
                    
                    if (tile.disasterEffect) {
                        classes += ` ${tile.disasterEffect}`;
                    }
                    
                    // Add building efficiency glow if the tile has a building
                    if (tile.building && !tile.isConstruction && !tile.isBroken && tile.building !== 'town') {
                        const efficiency = this.calculateBuildingEfficiency(tile, index);
                        const glowClass = this.getGlowClass(efficiency);
                        if (glowClass) classes += ` ${glowClass}`;
                    }
                    
                    div.className = classes;
                    div.onclick = () => this.handleTileClick(index);
                    div.onmouseenter = () => this.showTileInfo(index);

                    // Icon Logic
                    if (tile.isConstruction) {
                        const i = document.createElement('i');
                        i.setAttribute('data-lucide', 'hammer');
                        i.style.color = '#facc15';
                        i.style.width = '50%';
                        i.style.height = '50%';
                        i.style.filter = 'drop-shadow(0 0 5px #ca8a04)';
                        
                        const progress = document.createElement('div');
                        progress.className = 'build-progress';
                        // Use simple width transition
                        setTimeout(() => progress.style.width = '100%', 10);
                        
                        div.appendChild(progress);
                        
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.appendChild(i);
                    } 
                    else if(tile.river)
                    {
                       const i = document.createElement('i');
                        i.setAttribute('data-lucide', 'droplets');
                        i.style.color = '#22c55e';
                        i.style.width = '70%';
                        i.style.height = '70%';
                        i.style.filter = 'drop-shadow(0 0 8px #15803d)';
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.appendChild(i);
                    }
                    else if (tile.isBroken) {
                        const i = document.createElement('i');
                        i.setAttribute('data-lucide', 'alert-triangle'); // Hazard icon
                        i.style.color = '#ef4444';
                        i.style.width = '60%';
                        i.style.height = '60%';
                        
                        const smoke = document.createElement('div');
                        smoke.className = 'smoke-overlay';
                        smoke.innerText = '☁️'; 
                        div.appendChild(smoke);

                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.appendChild(i);
                    }
                    else if (tile.type === 'town') {
                        const i = document.createElement('i');
                        i.setAttribute('data-lucide', 'home'); 
                        // Change icon color based on power state
                        i.style.color = this.townPowered ? '#a5b4fc' : '#374151'; 
                        i.style.width = '50%';
                        i.style.height = '50%';
                        i.style.filter = this.townPowered ? 'drop-shadow(0 0 10px #6366f1)' : 'none';
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.appendChild(i);
                    } else if (tile.type === 'river' && !tile.building) {
                        const i = document.createElement('i');
                        i.setAttribute('data-lucide', 'waves');
                        i.style.color = '#38bdf8';
                        i.style.width = '60%';
                        i.style.height = '60%';
                        i.style.filter = 'drop-shadow(0 0 5px #0284c7)';
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.appendChild(i);
                    } else if (tile.type === 'forest') {
                        const i = document.createElement('i');
                        i.setAttribute('data-lucide', 'tree-pine');
                        i.style.color = '#22c55e';
                        i.style.width = '70%';
                        i.style.height = '70%';
                        i.style.filter = 'drop-shadow(0 0 8px #15803d)';
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.appendChild(i);
                    } else if (tile.type === 'mountain') {
                        const i = document.createElement('i');
                        i.setAttribute('data-lucide', 'mountain');
                        i.style.color = '#a1a1aa';
                        i.style.width = '70%';
                        i.style.height = '70%';
                        i.style.filter = 'drop-shadow(0 0 8px #52525b)';
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.appendChild(i);
                    } else if (tile.building) {
                        const i = document.createElement('i');
                        const iconMap = { solar: 'solar-panel', wind: 'fan', hydro: 'dam', battery: 'battery-charging', export: 'upload-cloud' };
                        const colorMap = { solar: '#93c5fd', wind: '#f472b6', hydro: '#ffffff', battery: '#4ade80', export: '#c084fc' };
                        
                        i.setAttribute('data-lucide', iconMap[tile.building]);
                        i.style.color = colorMap[tile.building];
                        i.style.width = '60%';
                        i.style.height = '60%';
                        i.style.filter = `drop-shadow(0 0 5px ${colorMap[tile.building]})`;
                        
                        div.style.display = 'flex';
                        div.style.alignItems = 'center';
                        div.style.justifyContent = 'center';
                        div.appendChild(i);
                    }
                    container.appendChild(div);
                });
                lucide.createIcons();

                // Add a single mouseleave event to the container to handle all tiles
                container.onmouseleave = () => {
                    this.isGridHover = false;
                    this.hideBuildCursor();
                    if (this.selectedTool) {
                        this.updateInfoPanel(this.selectedTool);
                    }
                };
            },

            moveBuildCursor(e) {
                if (!this.buildCursorEl) return;
                if (!this.selectedTool || !this.isGridHover) {
                    this.hideBuildCursor();
                    return;
                }
                this.buildCursorEl.style.display = 'flex';
                this.buildCursorEl.style.left = `${e.clientX}px`;
                this.buildCursorEl.style.top = `${e.clientY}px`;
            },

            hideBuildCursor() {
                if (this.buildCursorEl) {
                    this.buildCursorEl.style.display = 'none';
                }
            },

            updateBuildCursor() {
                if (!this.buildCursorEl) return;
                const iconMap = { solar: 'solar-panel', wind: 'fan', hydro: 'dam', battery: 'battery-charging', export: 'upload-cloud', bulldoze: 'trash-2', upgrade: 'zap' };
                const colorMap = { solar: '#93c5fd', wind: '#f472b6', hydro: '#38bdf8', battery: '#4ade80', export: '#c084fc', bulldoze: '#ef4444', upgrade: '#a855f7' };
                const icon = iconMap[this.selectedTool];
                if (!icon) {
                    this.buildCursorEl.innerHTML = '';
                    this.hideBuildCursor();
                    return;
                }
                const color = colorMap[this.selectedTool] || 'var(--neon-cyan)';
                this.buildCursorEl.style.borderColor = color;
                this.buildCursorEl.style.boxShadow = `0 0 16px ${color}55`;
                this.buildCursorEl.innerHTML = `<i data-lucide="${icon}" class="w-5 h-5"></i>`;
                this.buildCursorEl.style.display = 'flex';
                lucide.createIcons();
            },

            selectTool(tool) {
                this.selectedTool = tool;
                document.querySelectorAll('.tech-btn').forEach(b => b.classList.remove('selected'));
                if (tool !== 'upgrade') {
                    const btn = document.getElementById(`btn-${tool}`);
                    if(btn) btn.classList.add('selected');
                }
                this.updateInfoPanel(tool);
                this.updateBuildCursor();
            },

            async getAdvisorTip() {
                
                const advisorPanel = document.getElementById('advisor-panel');
                advisorPanel.innerHTML = `
                    <div class="advisor-row">
                        <div class="advisor-avatar">
                            <img src="${this.getFarmerAvatar()}" alt="Advisor">
                        </div>
                        <div class="advisor-bubble">
                            <div class="advisor-meta">Bob the Builder</div>
                            <div class="text-sm text-gray-300 leading-relaxed">Advisor is thinking...</div>
                        </div>
                    </div>`;

                try {
                    // Gather rich context from helper methods
                    const buildingBreakdown = this.getBuildingBreakdown();
                    const energyBalance = this.getEnergyBalance();
                    const batteryInfo = this.getBatteryUtilization();
                    const terrain = this.getTerrainAnalysis();
                    const budgetStatus = this.getBudgetStatus();
                    const regionOptimization = this.getRegionalOptimization();
                    const availableSlots = this.getAvailableGridSlots();
                    const limits = this.limits;

                    const response = await fetch('/api/advisor', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            gridState: this.grid.map(t => ({ type: t.type, building: t.building })),
                            budget: this.budget,
                            demand: this.demand,
                            production: this.getAverageProduction(),
                            buildingBreakdown: buildingBreakdown,
                            energyBalance: energyBalance,
                            batteryInfo: batteryInfo,
                            terrain: terrain,
                            budgetStatus: budgetStatus,
                            regionOptimization: regionOptimization,
                            region: this.currentRegion,
                            upgradeLevel: this.upgradeLevel,
                            availableLandSlots: availableSlots.length,
                            limits: limits
                        })
                    });

                    if (!response.ok) throw new Error('Advisor unavailable');

                    const data = await response.json();
                    const advice = data.message || 'No advice available';
                    
                    advisorPanel.innerHTML = `
                        <div class="advisor-row">
                            <div class="advisor-avatar">
                                <img src="${this.getFarmerAvatar()}" alt="Advisor">
                            </div>
                            <div class="advisor-bubble">
                                <div class="advisor-meta">Bob the Builder</div>
                                <div class="text-gray-100 text-sm leading-relaxed">${advice}</div>
                            </div>
                        </div>
                    `;
                } catch (err) {
                    advisorPanel.innerHTML = `
                        <div class="advisor-row">
                            <div class="advisor-avatar">
                                <img src="${this.getFarmerAvatar()}" alt="Advisor">
                            </div>
                            <div class="advisor-bubble error">
                                <div class="advisor-meta">Bob the Builder</div>
                                <div class="text-red-300 text-sm leading-relaxed">Advisor offline. Make sure server is running on port 3000.</div>
                            </div>
                        </div>`;
                }
            },

            getSunBoost(index) {
                // Sun is at the top center of the grid
                // Grid is 8x8, so center column is between 3 and 4
                const col = index % 8;
                const row = Math.floor(index / 8);
                const centerCol = 3.5;
                
                // Distance in tiles: only horizontal distance + vertical distance from top
                const horizontalDist = Math.abs(col - centerCol);
                const verticalDist = row; // Distance from top row
                const totalDist = horizontalDist + verticalDist; // Manhattan distance (simpler and more predictable)
                
                // 3-tile radius boost (gradient falloff)
                // At distance 0-3: apply boost, fading linearly
                if (totalDist <= 3) {
                    const boostAmount = 0.30 * (1 - (totalDist / 3)); // 30% max at center, 0% at radius 3
                    return 1.0 + boostAmount;
                }
                return 1.0;
            },

            getNearbyRiverBoost(index) {
                // Check 1-tile radius around this position for rivers
                const col = index % 8;
                const row = Math.floor(index / 8);
                const directions = [-9, -8, -7, -1, 1, 7, 8, 9]; // All 8 adjacent tiles
                
                let hasNearbyRiver = false;
                for (let offset of directions) {
                    const neighborIdx = index + offset;
                    if (neighborIdx >= 0 && neighborIdx < 64) {
                        // Check column wrap-around (don't check diagonally across grid edges)
                        const neighborCol = neighborIdx % 8;
                        const colDiff = Math.abs(col - neighborCol);
                        if (colDiff <= 1 && this.grid[neighborIdx] && this.grid[neighborIdx].type === 'river') {
                            hasNearbyRiver = true;
                            break;
                        }
                    }
                }
                
                // Wind gets 15% boost if near a river
                return hasNearbyRiver ? 1.15 : 1.0;
            },

            calculateBuildingEfficiency(tile, index) {
                /**
                 * Calculates the production efficiency of a building as a percentage (0-1).
                 * Takes into account:
                 * - Building type and base output
                 * - Environmental factors (season, weather, sun/river boosts)
                 * - Disaster effects (cloud cover, drought)
                 * - Upgrade level
                 * - Current battery state (for solar)
                 */
                if (!tile.building || tile.building === 'town' || tile.building === 'export' || tile.isConstruction || tile.isBroken) {
                    return 0; // No efficiency for non-production buildings
                }

                const multiplier = 1 + (this.upgradeLevel * CONFIG.upgrade.multiplierPerLevel);
                const currentMonth = this.isSimulating ? this.simMonth : 0;
                const baseConfig = CONFIG.buildings[tile.building];
                
                let efficiency = 1.0;

                if (tile.building === 'solar') {
                    // Solar: affected by season, weather, sun boost, and cloud cover
                    let seasonMod = SEASONALITY.solar[currentMonth] || 1.0;
                    let sunBoost = this.getSunBoost(index);
                    let weatherMod = CONFIG.weather.solar;
                    
                    // Check for cloud cover disaster
                    if (tile.disasterEffect === 'effect-cloud') {
                        weatherMod *= 0.4; // 60% reduction from clouds
                    }
                    
                    efficiency = (seasonMod * sunBoost * weatherMod * multiplier) * .66666; // 33% night loss factored
                } 
                else if (tile.building === 'wind') {
                    // Wind: affected by season, weather, river boost
                    let seasonMod = SEASONALITY.wind[currentMonth] || 1.0;
                    let riverBoost = this.getNearbyRiverBoost(index);
                    let weatherMod = CONFIG.weather.wind;
                    
                    // Cloud cover actually BOOSTS wind
                    if (tile.disasterEffect === 'effect-cloud') {
                        weatherMod *= 1.3; // 30% boost from wind conditions
                    }
                    
                    efficiency = (seasonMod * riverBoost * weatherMod * multiplier);
                } 
                else if (tile.building === 'hydro') {
                    // Hydro: affected by season, weather, drought
                    let seasonMod = SEASONALITY.hydro[currentMonth] || 1.0;
                    let weatherMod = CONFIG.weather.hydro;
                    
                    // Drought completely disables hydro
                    if (tile.disasterEffect === 'effect-drought') {
                        efficiency = 0;
                    } else {
                        efficiency = (seasonMod * weatherMod * multiplier);
                    }
                } 
                else if (tile.building === 'battery') {
                    // Battery efficiency is based on charge level
                    const maxCap = CONFIG.buildings.battery.capacity;
                    efficiency = this.batteryCharge / maxCap; // 0-1 based on charge level
                }

                // Clamp efficiency to 0-1 range and apply upgrade multiplier
                efficiency = Math.min(1.0, Math.max(0, efficiency));
                
                return efficiency;
            },

            getGlowClass(efficiency) {
                /**
                 * Returns the appropriate CSS glow class based on efficiency percentage.
                 * Efficiency should be a value between 0-1.
                 */
                if (efficiency >= 0.80) {
                    return 'building-glow-optimal'; // Bright green pulsing glow
                } else if (efficiency >= 0.60) {
                    return 'building-glow-high'; // Strong cyan glow
                } else if (efficiency >= 0.30) {
                    return 'building-glow-medium'; // Blue glow
                } else if (efficiency > 0) {
                    return 'building-glow-low'; // Subtle grey glow
                }
                return ''; // No glow for 0 efficiency
            },

            getAverageDemand() {
                const totalDemand = REGIONS[this.currentRegion].demand * 12;
                return Math.floor(totalDemand / 12);
            },

            getAverageProduction() {
                let totalProduction = 0;
                this.grid.forEach(tile => {
                    if (tile.building && tile.building !== 'town') {
                        const config = CONFIG.buildings[tile.building];
                        if (config) {
                            totalProduction += config.output;
                        }
                    }
                });
                return Math.floor(totalProduction);
            },

            getBuildingBreakdown() {
                const breakdown = { solar: 0, wind: 0, hydro: 0, battery: 0, export: 0 };
                this.grid.forEach(tile => {
                    if (tile.building && breakdown.hasOwnProperty(tile.building)) {
                        breakdown[tile.building]++;
                    }
                });
                return breakdown;
            },

            getEnergyBalance() {
                const avgDemand = this.getAverageDemand();
                const avgProduction = this.getAverageProduction();
                const deficit = avgDemand - avgProduction;
                return { deficit, surplus: Math.max(0, -deficit), balance: deficit };
            },

            getBatteryUtilization() {
                let totalBattery = 0;
                let totalCapacity = 0;
                this.grid.forEach(tile => {
                    if (tile.building === 'battery') {
                        totalBattery++;
                        totalCapacity += CONFIG.buildings.battery.capacity;
                    }
                });
                return { count: totalBattery, capacity: totalCapacity };
            },

            getSolarCoverage() {
                let solarCount = 0;
                this.grid.forEach(tile => {
                    if (tile.building === 'solar') solarCount++;
                });
                return solarCount;
            },

            getWindCoverage() {
                let windCount = 0;
                this.grid.forEach(tile => {
                    if (tile.building === 'wind') windCount++;
                });
                return windCount;
            },

            getHydroCoverage() {
                let hydroCount = 0;
                this.grid.forEach(tile => {
                    if (tile.building === 'hydro') hydroCount++;
                });
                return hydroCount;
            },

            getExportCoverage() {
                let exportCount = 0;
                this.grid.forEach(tile => {
                    if (tile.building === 'export') exportCount++;
                });
                return exportCount;
            },

            getTerrainAnalysis() {
                let riverTiles = 0, forestTiles = 0, mountainTiles = 0, buildableTiles = 0;
                this.grid.forEach(tile => {
                    if (tile.type === 'river') riverTiles++;
                    else if (tile.type === 'forest') forestTiles++;
                    else if (tile.type === 'mountain') mountainTiles++;
                    else if (tile.type === 'land') buildableTiles++;
                });
                return { river: riverTiles, forest: forestTiles, mountain: mountainTiles, buildable: buildableTiles };
            },

            getBudgetStatus() {
                const spent = CONFIG.budget - this.budget;
                const remaining = this.budget;
                const percentUsed = (spent / CONFIG.budget) * 100;
                return { spent: Math.floor(spent), remaining: Math.floor(remaining), percentUsed: Math.floor(percentUsed) };
            },

            hasAdjacentGenerator(index) {
                const size = CONFIG.gridSize;
                const row = Math.floor(index / size);
                const col = index % size;
                const neighbors = [];
                if (col > 0) neighbors.push(index - 1);
                if (col < size - 1) neighbors.push(index + 1);
                if (row > 0) neighbors.push(index - size);
                if (row < size - 1) neighbors.push(index + size);
                return neighbors.some(i => {
                    const neighbor = this.grid[i];
                    if (!neighbor) return false;
                    const unit = neighbor.building || neighbor.pendingType;
                    return unit === 'solar' || unit === 'wind';
                });
            },

            getRegionalOptimization() {
                const region = REGIONS[this.currentRegion];
                const solar = this.getSolarCoverage();
                const wind = this.getWindCoverage();
                const hydro = this.getHydroCoverage();
                
                // Calculate suitability scores based on regional yields
                const solarSuitability = region.solarYield;
                const windSuitability = region.windYield;
                const hydroSuitability = region.hydroYield;
                
                return {
                    solar: { count: solar, suitability: solarSuitability },
                    wind: { count: wind, suitability: windSuitability },
                    hydro: { count: hydro, suitability: hydroSuitability }
                };
            },

            /**
             * Finds all available slots on the grid for terrain analysis or construction.
             * An available slot is one that is of type 'land' and not currently occupied.
             *
             * @returns {{id: number, x: number, y: number}[]} An array of coordinate objects for available slots.
             */
            getAvailableGridSlots() {
                const availableSlots = [];
                this.grid.forEach((tile, index) => {
                    if (tile.type === 'land' && !tile.building && !tile.isConstruction) {
                        availableSlots.push({ id: index, x: index % CONFIG.gridSize, y: Math.floor(index / CONFIG.gridSize) });
                    }
                });
                return availableSlots;
            },

            findTownPlacement(size, availableSet) {
                // Try 2x2 block
                if (size >= 4) {
                    for (let r = 0; r < 7; r++) {
                        for (let c = 0; c < 7; c++) {
                            const idx = r * 8 + c;
                            const block = [idx, idx + 1, idx + 8, idx + 9];
                            if (block.every(i => availableSet.has(i))) return block;
                        }
                    }
                }

                // Try 1x3 or 3x1 lines
                if (size >= 3) {
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c <= 8 - 3; c++) {
                            const idx = r * 8 + c;
                            const line = [idx, idx + 1, idx + 2];
                            if (line.every(i => availableSet.has(i))) return line;
                        }
                    }
                    for (let c = 0; c < 8; c++) {
                        for (let r = 0; r <= 8 - 3; r++) {
                            const idx = r * 8 + c;
                            const line = [idx, idx + 8, idx + 16];
                            if (line.every(i => availableSet.has(i))) return line;
                        }
                    }
                }

                // Try 1x2 or 2x1 pairs
                if (size >= 2) {
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 7; c++) {
                            const idx = r * 8 + c;
                            const pair = [idx, idx + 1];
                            if (pair.every(i => availableSet.has(i))) return pair;
                        }
                    }
                    for (let r = 0; r < 7; r++) {
                        for (let c = 0; c < 8; c++) {
                            const idx = r * 8 + c;
                            const pair = [idx, idx + 8];
                            if (pair.every(i => availableSet.has(i))) return pair;
                        }
                    }
                }

                // Fallback single tile
                for (let idx of availableSet) {
                    return [idx];
                }
                return [];
            },

            expandTownForNewYear() {
                const available = this.getAvailableGridSlots();
                if (!available.length) return { tiles: 0, demandIncrease: 0 };

                const availableSet = new Set(available.map(s => s.id));
                let desiredSize = Math.min(4, available.length);
                // Prefer 4, then 3, then 2, then 1 based on availability
                let placement = [];
                for (let sz = desiredSize; sz >= 1; sz--) {
                    placement = this.findTownPlacement(sz, availableSet);
                    if (placement.length) break;
                }
                if (!placement.length) return { tiles: 0, demandIncrease: 0 };

                const prevTownTiles = Math.max(1, this.townIndices.length || 1);
                placement.forEach(idx => {
                    this.grid[idx].type = 'town';
                    this.grid[idx].building = 'town';
                    this.townIndices.push(idx);
                });

                // Demand increase scaled to existing demand per town tile, slightly discounted
                const perTileDemand = Math.max(300, Math.floor((CONFIG.demand / prevTownTiles) * 0.75));
                const demandIncrease = perTileDemand * placement.length;
                CONFIG.demand += demandIncrease;
                REGIONS[this.currentRegion].baselineDemandKWh = CONFIG.demand;
                REGIONS[this.currentRegion].demand = CONFIG.demand;

                document.getElementById('ui-param-demand').innerText = `${CONFIG.demand.toLocaleString()} MWh`;
                return { tiles: placement.length, demandIncrease };
            },

            showTileInfo(index) {
                const tile = this.grid[index];
                const titleEl = document.getElementById('info-title');
                const bodyEl = document.getElementById('info-body');
                const tipEl = document.getElementById('info-tip');
                const panel = document.getElementById('tool-info-panel');

                panel.className = "w-full max-w-md bg-[#131620] border border-slate-700 rounded p-3 min-h-[70px] flex flex-col justify-center transition-all";
                titleEl.className = "text-neon-cyan font-bold text-xs tracking-[0.2em] mb-1";
                bodyEl.className = "text-gray-400 text-xs leading-relaxed";
                tipEl.classList.add('hidden');

                titleEl.innerText = `TILE ${index} ANALYSIS`;
                const multiplier = 1 + (this.upgradeLevel * CONFIG.upgrade.multiplierPerLevel);
                let infoText = '';

                // Determine the current month for seasonal calculation. Defaults to 0 (JAN) if sim isn't running.
                const currentMonth = this.isSimulating ? this.simMonth : 0;

                // Built tile details with estimated output
                if (tile.building && !tile.isConstruction) {
                    const type = tile.building;
                    let estOutput = 0;
                    if (type === 'solar') {
                        const seasonMod = SEASONALITY.solar[currentMonth];
                        const sunBoost = this.getSunBoost(index);
                        const tileMod = tile.sunCoverage || 1;
                        estOutput = Math.floor(CONFIG.buildings.solar.output * CONFIG.weather.solar * multiplier * seasonMod * tileMod * sunBoost);
                        infoText = `Solar array active. Est. Output: <span class="text-blue-300 font-bold">${estOutput} MWh/mo</span>`;
                    } else if (type === 'wind') {
                        const seasonMod = SEASONALITY.wind[currentMonth];
                        const riverBoost = this.getNearbyRiverBoost(index);
                        const tileMod = tile.windSpeed || 1;
                        const windSeasonalTileMod = 1 + ((tileMod - 1) * seasonMod);
                        estOutput = Math.floor(CONFIG.buildings.wind.output * CONFIG.weather.wind * multiplier * seasonMod * windSeasonalTileMod * riverBoost);
                        infoText = `Wind turbine active. Est. Output: <span class="text-pink-300 font-bold">${estOutput} MWh/mo</span>`;
                    } else if (type === 'hydro') {
                        const seasonMod = SEASONALITY.hydro[currentMonth];
                        estOutput = Math.floor(CONFIG.buildings.hydro.output * CONFIG.weather.hydro * multiplier * seasonMod);
                        infoText = `Hydro plant active. Est. Output: <span class="text-cyan-300 font-bold">${estOutput} MWh/mo</span>`;
                    } else if (type === 'battery') {
                        const cap = CONFIG.buildings.battery.capacity;
                        infoText = `Battery storage. Capacity: <span class="text-green-300 font-bold">${cap} MWh</span>. Current charge: <span class="text-green-200 font-bold">${Math.floor(this.batteryCharge)} MWh</span>`;
                    } else if (type === 'export') {
                        infoText = `Export hub. Sells surplus power at <span class="text-purple-300 font-bold">${CONFIG.exportRate} cr/MWh</span>.`;
                    } else if (type === 'town') {
                        infoText = 'Town Center: Construction not permitted here.';
                    } else {
                        infoText = 'This tile is occupied.';
                    }
                    bodyEl.innerHTML = infoText.replace(/\n/g, '<br>');
                    return;
                }

                if (tile.type === 'land') {
                    const solarSeasonMod = SEASONALITY.solar[currentMonth];
                    const windSeasonMod = SEASONALITY.wind[currentMonth];
                    
                    const solarSeasonalTileMod = 1 + ((tile.sunCoverage - 1) * solarSeasonMod);
                    const windSeasonalTileMod = 1 + ((tile.windSpeed - 1) * windSeasonMod);
                    
                    // Apply sun boost and river wind boost
                    const sunBoost = this.getSunBoost(index);
                    const riverBoost = this.getNearbyRiverBoost(index);

                    const solar = Math.floor(CONFIG.buildings.solar.output * CONFIG.weather.solar * multiplier * solarSeasonMod * solarSeasonalTileMod * sunBoost);
                    const wind = Math.floor(CONFIG.buildings.wind.output * CONFIG.weather.wind * multiplier * windSeasonMod * windSeasonalTileMod * riverBoost);
                    
                    const sunLabel = sunBoost > 1.0 ? ` ☀️+${Math.round((sunBoost-1)*100)}%` : '';
                    const riverLabel = riverBoost > 1.0 ? ` 🍃+${Math.round((riverBoost-1)*100)}%` : '';
                    
                    infoText = `Potential Output (MWh/mo):\n<span class="text-blue-300">Solar: ${solar}${sunLabel}</span> | <span class="text-pink-300">Wind: ${wind}${riverLabel}</span> | <span class="text-gray-500">Hydro: N/A</span>`;
                } else if (tile.type === 'river') {
                    const hydro = Math.floor(CONFIG.buildings.hydro.output * CONFIG.weather.hydro * multiplier * SEASONALITY.hydro[currentMonth]);
                    infoText = `Potential Output (MWh/mo):\n<span class="text-gray-500">Solar: N/A</span> | <span class="text-gray-500">Wind: N/A</span> | <span class="text-cyan-300">Hydro: ${hydro}</span>`;
                } else if (tile.type === 'town') {
                    infoText = 'This is part of the Town Center. Construction is not permitted here.';
                } else if (tile.type === 'forest') {
                    infoText = 'Forest Obstacle: This area is too densely vegetated for construction.';
                } else if (tile.type === 'mountain') {
                    infoText = 'Mountain Obstacle: Terrain is unsuitable for building.';
                } else {
                    infoText = 'Analyzing tile data...';
                }

                bodyEl.innerHTML = infoText.replace(/\n/g, '<br>');
            },

            updateInfoPanel(tool) {
                const info = TOOL_INFO[tool];
                if (!info) return;

                const titleEl = document.getElementById('info-title');
                const bodyEl = document.getElementById('info-body');
                const tipEl = document.getElementById('info-tip');
                const panel = document.getElementById('tool-info-panel');

                panel.className = "w-full max-w-md bg-[#131620] border border-slate-700 rounded p-3 min-h-[70px] flex flex-col justify-center transition-all";
                titleEl.className = "text-neon-cyan font-bold text-xs tracking-[0.2em] mb-1";
                bodyEl.className = "text-gray-400 text-xs leading-relaxed";

                titleEl.innerText = info.title;
                bodyEl.innerText = info.desc;
                tipEl.innerText = `TIP: ${info.tip}`;
                tipEl.classList.remove('hidden');
            },

            buyUpgrade() {
                this.updateInfoPanel('upgrade');
                if (this.upgradeLevel >= CONFIG.upgrade.maxLevel) return;
                
                if (this.budget >= CONFIG.upgrade.cost) {
                    this.budget -= CONFIG.upgrade.cost;
                    this.upgradeLevel++;
                    
                    const btn = document.getElementById('btn-upgrade');
                    const txt = document.getElementById('upgrade-text');
                    const count = document.getElementById('upgrade-count');
                    
                    count.innerText = `${(this.upgradeLevel)*3}/${(CONFIG.upgrade.maxLevel)*3}`;
                    count.classList.add('text-neon-purple');
                    
                    if (this.upgradeLevel >= CONFIG.upgrade.maxLevel) {
                        btn.classList.add('opacity-50', 'pointer-events-none');
                        txt.innerText = "MAXED";
                        txt.classList.add('text-neon-purple');
                    }
                    
                    lucide.createIcons();
                    this.updateUI();
                    this.showMessage(`Efficiency Level ${this.upgradeLevel} Installed (+3%)`);
                } else {
                    this.showMessage("Insufficient Credits for Upgrade");
                }
            },

            isNoiseZone(index) {
                const x = index % 8;
                const y = Math.floor(index / 8);
                const inZone = (x >= 2 && x <= 5) && (y >= 2 && y <= 5);
                const isTown = this.townIndices.includes(index);
                return inZone && !isTown;
                const col = index % 8;
                // All 8 adjacent tiles, including diagonals
                const directions = [-9, -8, -7, -1, 1, 7, 8, 9]; 
                
                for (const offset of directions) {
                    const neighborIdx = index + offset;

                    // Check bounds
                    if (neighborIdx < 0 || neighborIdx >= 64) continue;

                    // Prevent wrap-around checks on edges
                    const neighborCol = neighborIdx % 8;
                    if (Math.abs(col - neighborCol) > 1) continue;

                    if (this.grid[neighborIdx] && this.grid[neighborIdx].type === 'town') {
                        return true; // It's adjacent to a town tile
                    }
                }
                
                return false;
            },

            finishConstruction(index, type) {
                const tile = this.grid[index];
                if (tile.isConstruction) {
                    tile.isConstruction = false;
                    tile.isBroken = false; // Ensure broken state is cleared after repair
                    tile.building = type;
                    this.activeBuilders--;
                    this.playSound('build');
                    this.renderGrid();
                    this.updateUI();
                    this.showMessage(`${type.toUpperCase()} Construction Complete`);
                }
            },

            handleTileClick(index) {
                const tile = this.grid[index];
                
                // Broken Tile Repair Logic
                if (tile.isBroken) {
                    if (this.selectedTool === 'bulldoze') {
                        // Allow bulldozing broken tile
                    } else {
                        // Repair logic (Clicking with any other tool triggers repair)
                        if (this.budget < CONFIG.repairCost) {
                            this.showMessage("Insufficient Credits for Repair");
                            return;
                        }
                        if (this.activeBuilders >= CONFIG.maxBuilders) {
                            this.showMessage("All Crews Busy!");
                            return;
                        }
                        
                        this.budget -= CONFIG.repairCost;
                        tile.isConstruction = true;
                        // tile.building remains set, so we know what we are repairing
                        this.activeBuilders++;
                        
                        this.renderGrid();
                        this.updateUI();
                        this.showMessage("Repair Crews Dispatched");
                        
                        setTimeout(() => {
                            this.finishConstruction(index, tile.building);
                        }, CONFIG.repairTime * 1000); // Repair is faster (3s)
                        return;
                    }
                }

                if (tile.type === 'town') {
                    this.showMessage("Town Center: Cannot build here.");
                    return;
                }

                if (tile.type === 'forest' || tile.type === 'mountain') {
                    this.showMessage("Cannot build on obstacles.");
                    const el = document.getElementById('game-grid').children[index];
                    el.style.backgroundColor = 'rgba(239, 68, 68, 0.5)';
                    setTimeout(() => el.style.backgroundColor = '', 200);
                    return;
                }

                if (this.selectedTool === 'bulldoze') {
                    if (tile.isConstruction) {
                        const type = tile.pendingType;
                        const refund = CONFIG.buildings[type] ? CONFIG.buildings[type].cost * 0.5 : 0;
                        this.budget -= refund;
                        
                        tile.isConstruction = false;
                        tile.building = null;
                        tile.pendingType = null;
                        tile.isBroken = false;
                        this.activeBuilders--;
                        
                        this.renderGrid();
                        this.updateUI();
                        this.showMessage(`Construction Cancelled. +${refund} Credits`);
                        return;
                    }
                    
                    if (tile.building) {
                        const refund = CONFIG.buildings[tile.building].cost * 0.5;
                        this.budget += refund;
                        tile.building = null;
                        tile.isBroken = false; // Ensure broken state clears
                        this.playSound('destroy');
                        this.renderGrid();
                        this.updateUI();
                        this.showMessage(`Unit dismantled. +${refund} Credits`);
                    } else {
                        this.showMessage("Nothing to bulldoze here.");
                    }
                    return;
                }

                if (!this.selectedTool) {
                    this.showMessage("Select a technology to build");
                    return;
                }

                if (tile.building || tile.isConstruction) {
                    this.showMessage("Site occupied. Use Bulldozer to clear.");
                    return;
                }

                const tech = CONFIG.buildings[this.selectedTool];

                // Placement restriction: batteries must be adjacent to solar or wind
                if (this.selectedTool === 'battery') {
                    const generatorExists = this.grid.some(t => {
                        const unit = t.building || t.pendingType;
                        return unit === 'solar' || unit === 'wind';
                    });
                    if (!generatorExists) {
                        this.showMessage("Build SOLAR or WIND first.");
                        return;
                    }
                    if (!this.hasAdjacentGenerator(index)) {
                        this.showMessage("Place next to SOLAR or WIND.");
                        return;
                    }
                }

                if (this.budget < tech.cost) {
                    this.showMessage("Insufficient Credits");
                    return;
                }

                if (this.activeBuilders >= CONFIG.maxBuilders) {
                    this.showMessage("All Construction Crews Busy!");
                    return;
                }

                if (tech.type !== tile.type) {
                    this.showMessage(`Cannot build ${this.selectedTool} here.`);
                    const el = document.getElementById('game-grid').children[index];
                    el.style.backgroundColor = 'rgba(239, 68, 68, 0.5)';
                    setTimeout(() => el.style.backgroundColor = '', 200);
                    return;
                }

                // Check Limits
                const currentCount = this.grid.filter(t => (t.building === this.selectedTool || t.pendingType === this.selectedTool) && !t.isBroken).length;
                if (currentCount >= this.limits[this.selectedTool]) {
                    this.showMessage(`Building Limit Reached (${this.limits[this.selectedTool]} Max)`);
                    return;
                }

                if (this.selectedTool === 'wind' && this.isNoiseZone(index)) {
                    this.showMessage("WARNING: Turbine near town reduces reliability & budget!");
                }

                this.budget -= tech.cost;
                tile.isConstruction = true;
                tile.pendingType = this.selectedTool;
                this.activeBuilders++;
                this.playSound('build');
                
                this.renderGrid();
                this.updateUI();
                
                setTimeout(() => {
                    this.finishConstruction(index, tile.pendingType);
                }, CONFIG.constructionTime * 1000);
            },

            showMessage(msg) {
                const titleEl = document.getElementById('info-title');
                const bodyEl = document.getElementById('info-body');
                const tipEl = document.getElementById('info-tip');
                const panel = document.getElementById('tool-info-panel');

                panel.className = "w-full max-w-md bg-red-900 border border-red-500 rounded p-3 min-h-[70px] flex flex-col justify-center transition-all";
                titleEl.className = "text-red-400 font-bold text-xs tracking-[0.2em] mb-1";
                bodyEl.className = "text-red-200 text-xs font-bold";
                
                titleEl.innerText = "SYSTEM ALERT";
                bodyEl.innerText = msg;
                tipEl.classList.add('hidden');

                setTimeout(() => {
                    if (titleEl.innerText === "SYSTEM ALERT") {
                        if (this.selectedTool) {
                            this.updateInfoPanel(this.selectedTool);
                        } else {
                            panel.className = "w-full max-w-md bg-[#131620] border border-slate-700 rounded p-3 min-h-[70px] flex flex-col justify-center transition-all";
                            titleEl.className = "text-neon-cyan font-bold text-xs tracking-[0.2em] mb-1";
                            bodyEl.className = "text-gray-400 text-xs leading-relaxed";
                            titleEl.innerText = "SYSTEM READY";
                            bodyEl.innerText = "Select a technology to view specifications and tactical data.";
                            tipEl.classList.add('hidden');
                        }
                    }
                }, 2500);
            },

            showDisasterAlert(msg) {
                const el = document.getElementById('disaster-alert');
                el.textContent = `WARNING: ${msg}`;
                el.style.opacity = 1;
            },

            playSound(kind) {
                const audioEl = this.audio[kind];
                if (audioEl) {
                    audioEl.currentTime = 0;
                    audioEl.play().catch(() => {});
                }
            },

            getFarmerAvatar() {
                const idx = Math.floor(Math.random() * 7) + 1;
                return `farmer/farmer${idx}.png`;
            },

            setAdvisorIdleMessage() {
                const advisorPanel = document.getElementById('advisor-panel');
                if (!advisorPanel) return;
                const avatar = this.getFarmerAvatar();
                advisorPanel.innerHTML = `
                    <div class="advisor-row">
                        <div class="advisor-avatar">
                            <img src="${avatar}" alt="Advisor">
                        </div>
                        <div class="advisor-bubble">
                            <div class="advisor-meta">Bob the Builder</div>
                            <div class="text-sm text-gray-300 leading-relaxed">
                                Click "GET TIP" for recommendations based on your current grid.
                            </div>
                        </div>
                    </div>
                `;
            },
            
            hideDisasterAlert() {
                document.getElementById('disaster-alert').style.opacity = 0;
            },

            updateUI() {
                document.getElementById('budget-display').innerText = Math.floor(this.budget);
                document.getElementById('builders-display').innerText = `${CONFIG.maxBuilders - this.activeBuilders}/${CONFIG.maxBuilders}`;
                
                const counts = { solar: 0, wind: 0, hydro: 0, battery: 0, export: 0 };
                let totalCap = 0;
                let totalCount = 0;
                let totalBatCap = 0;
                const multiplier = 1 + (this.upgradeLevel * CONFIG.upgrade.multiplierPerLevel);

                this.grid.forEach(t => {
                    const type = t.building || t.pendingType;
                    if (type && type !== 'town') {
                        if (counts[type] !== undefined) counts[type]++;
                    }
                    
                    // Exclude broken buildings from output calculation
                    if (t.building && t.building !== 'town' && !t.isConstruction && !t.isBroken) {
                        if (t.building === 'battery') {
                            totalBatCap += CONFIG.buildings.battery.capacity;
                        } else if (t.building !== 'export') {
                            totalCount++;
                            totalCap += (CONFIG.buildings[t.building].output * CONFIG.weather[t.building] * multiplier);
                        }
                    }
                });

                ['solar', 'wind', 'hydro', 'battery', 'export'].forEach(type => {
                    const limit = this.limits[type];
                    const count = counts[type];
                    const el = document.getElementById(`limit-${type}`);
                    if (el) {
                        el.innerText = `${count}/${limit}`;
                        el.className = count >= limit 
                            ? "text-[9px] text-red-400 font-mono font-bold" 
                            : "text-[9px] text-gray-500 font-mono";
                    }
                });

                if (!this.isSimulating || this.inGracePeriod) {
                    document.getElementById('stat-capacity').innerHTML = `${Math.floor(totalCap)} <span class="text-xs text-gray-500 font-sans">MWh</span>`;
                    document.getElementById('stat-battery').innerText = `${Math.floor(this.batteryCharge)} / ${totalBatCap} MWh`;
                    const pct = totalBatCap > 0 ? (this.batteryCharge / totalBatCap) * 100 : 0;
                    document.getElementById('battery-bar').style.width = `${pct}%`;
                }

                // Update Grid Status Bars
                const avgDemand = this.getAverageDemand();
                const avgProduction = this.getAverageProduction();

                // Building counts with limits
                const totalBuildings = Object.values(counts).reduce((a, b) => a + b, 0);
                ['solar', 'wind', 'hydro', 'battery', 'export'].forEach(type => {
                    const count = counts[type];
                    const limit = this.limits[type];
                    const percent = (count / limit) * 100;
                    
                    document.getElementById(`${type}-limit`).innerText = `${count}/${limit}`;
                    document.getElementById(`bar-${type}${type === 'battery' ? '-count' : ''}`).style.width = `${percent}%`;
                    
                    // Color bar red if at limit
                    const bar = document.getElementById(`bar-${type}${type === 'battery' ? '-count' : ''}`);
                    if (count >= limit) {
                        bar.className = 'bar-fill' + (type === 'solar' ? ' grad-blue opacity-50' : type === 'wind' ? ' grad-pink opacity-50' : type === 'hydro' ? ' grad-cyan opacity-50' : type === 'battery' ? ' grad-green opacity-50' : ' grad-orange opacity-50');
                    } else {
                        bar.className = 'bar-fill' + (type === 'solar' ? ' grad-blue' : type === 'wind' ? ' grad-pink' : type === 'hydro' ? ' grad-cyan' : type === 'battery' ? ' grad-green' : ' grad-orange');
                    }
                });

                // Budget utilization
                const budgetUsed = CONFIG.budget - this.budget;
                const budgetPercent = (budgetUsed / CONFIG.budget) * 100;
                document.getElementById('budget-percent').innerText = `${Math.floor(budgetPercent)}%`;
                document.getElementById('bar-budget').style.width = `${budgetPercent}%`;
            },

            // --- SIMULATION LOGIC ---

            toggleSimulation() {
                if (this.isSimulating) {
                    this.stopSimulation();
                } else {
                    this.startSimulation();
                }
            },

            updatePredictions() {
                // Calculate predicted capacity and months powered BEFORE simulation runs
                const multiplier = 1 + (this.upgradeLevel * CONFIG.upgrade.multiplierPerLevel);
                let totalCapacity = 0;
                let totalBatCap = 0;
                
                this.grid.forEach((t, idx) => {
                    if (t.building && t.building !== 'town' && !t.isConstruction && !t.isBroken) {
                        if (t.building === 'battery') {
                            totalBatCap += CONFIG.buildings.battery.capacity;
                        } else if (t.building !== 'export') {
                            // Average across all seasons
                            const avgSeason = (SEASONALITY[t.building] || [1]).reduce((a, b) => a + b, 0) / 12;
                            let boostMult = 1.0;
                            if (t.building === 'solar') boostMult = this.getSunBoost(idx);
                            else if (t.building === 'wind') boostMult = this.getNearbyRiverBoost(idx);
                            
                            totalCapacity += (CONFIG.buildings[t.building].output * CONFIG.weather[t.building] * multiplier * avgSeason * boostMult);
                        }
                    }
                });
                
                const baseMonthlyDemand = CONFIG.demand / 12;
                const avgDemandMultiplier = DEMAND_CURVE.reduce((a, b) => a + b, 0) / 12;
                const avgMonthlyDemand = baseMonthlyDemand * avgDemandMultiplier;
                
                // Estimate months powered (rough - assumes 33% solar loss and no disasters)
                const solarFraction = this.grid.filter(t => t.building === 'solar' && !t.isBroken).length / Math.max(1, this.grid.filter(t => t.building).length);
                const solarLoss = solarFraction * 0.33; // 33% of production lost for solar
                const effectiveCapacity = totalCapacity * (1 - solarLoss);
                const powerAvailable = effectiveCapacity + totalBatCap * 0.5; // Battery can help
                
                const monthsPowered = Math.min(12, Math.round((powerAvailable / Math.max(avgMonthlyDemand, 1)) * 12));
                
                document.getElementById('pred-capacity').innerText = `${Math.floor(totalCapacity)} MWh/mo`;
                document.getElementById('pred-demand').innerText = `${Math.floor(avgMonthlyDemand)} MWh/mo`;
                document.getElementById('pred-months').innerText = `${monthsPowered} / 12`;
                
                // Color code the prediction
                const monthsEl = document.getElementById('pred-months');
                if (monthsPowered >= 10) monthsEl.className = 'text-neon-green font-bold font-mono';
                else if (monthsPowered >= 6) monthsEl.className = 'text-neon-orange font-bold font-mono';
                else monthsEl.className = 'text-red-400 font-bold font-mono';
            },

            setSpeed(spd) {
                this.speedMultiplier = spd;
                const slider = document.getElementById('speed-slider');
                if (slider) {
                    slider.value = spd;
                    document.getElementById('speed-display').innerText = spd === 1 ? '1x' : spd + 'x';
                }
            },

            startSimulation() {
                this.isSimulating = true;
                
                this.selectedTool = null;
                this.updateBuildCursor();
                document.querySelectorAll('.tech-btn').forEach(b => b.classList.remove('selected'));
                this.renderGrid(); 

                this.simMonth = 0;
                this.monthlyHistory = []; // Reset monthly history for new simulation
                this.simResults = { production: 0, monthsPowered: 0, envSum: 0, totalDemandSoFar: 0, exportEarnings: 0 }; // Reset export earnings
                this.batteryCharge = 0; 
                
                this.setSpeed(1);
                this.activeEvents = [];

                document.getElementById('sim-running-ui').classList.remove('hidden');
                document.getElementById('sim-predictions').classList.add('hidden');
                document.getElementById('sim-placeholder').classList.add('hidden');
                
                // Reset Results panel if visible
                document.getElementById('results-container').classList.add('hidden');

                // Setup slider listener
                const slider = document.getElementById('speed-slider');
                if (slider) {
                    slider.onchange = (e) => this.setSpeed(parseInt(e.target.value));
                    slider.oninput = (e) => {
                        document.getElementById('speed-display').innerText = e.target.value + 'x';
                        this.speedMultiplier = parseInt(e.target.value);
                    };
                }

                document.getElementById('btn-run').innerText = "STOP SIMULATION";
                document.getElementById('btn-run').classList.remove('from-blue-600', 'to-indigo-600', 'border-blue-400', 'from-green-600', 'to-green-800', 'border-green-500');
                document.getElementById('btn-run').classList.add('from-red-600', 'to-red-800', 'border-red-500');
                document.getElementById('analysis-text').innerText = "Simulation In Progress...";
                
                ['autonomy', 'reliability', 'env', 'cost'].forEach(k => {
                    document.getElementById(`bar-${k}`).style.width = '0%';
                    document.getElementById(`score-${k}`).innerText = '0%';
                });

                this.startGracePeriod();
            },

            startGracePeriod() {
                this.inGracePeriod = true;
                this.graceTimerVal = CONFIG.gracePeriodDuration;
                this.runGraceTick();
            },

            runGraceTick() {
                if (!this.isSimulating || !this.inGracePeriod) return;

                document.getElementById('sim-month').innerText = "PREP";
                document.getElementById('sim-month').className = "text-2xl font-bold digit-font text-neon-cyan"; 
                document.getElementById('sim-year-prog').innerText = `T-MINUS ${this.graceTimerVal}s`;
                document.getElementById('analysis-text').innerText = "DEPLOYMENT PHASE: Finalize grid setup before simulation begins.";

                if (this.graceTimerVal <= 0) {
                    this.inGracePeriod = false;
                    document.getElementById('sim-month').className = "text-2xl font-bold digit-font text-neon-orange"; 
                    this.runMonthTick();
                    return;
                }

                this.graceTimerVal--;
                
                const delay = 1000 / this.speedMultiplier; 
                this.simTimer = setTimeout(() => this.runGraceTick(), delay);
            },

            stopSimulation() {
                this.isSimulating = false;
                this.inGracePeriod = false;
                clearTimeout(this.simTimer);
                this.activeEvents = [];
                this.clearDisasters();
                this.hideDisasterAlert();
                this.renderGrid(); 
                
                document.getElementById('sim-running-ui').classList.add('hidden');
                document.getElementById('sim-predictions').classList.remove('hidden');
                document.getElementById('sim-placeholder').classList.add('hidden');
                
                document.getElementById('btn-run').innerText = "RUN SIMULATION";
                document.getElementById('btn-run').classList.add('from-blue-600', 'to-indigo-600', 'border-blue-400');
                document.getElementById('btn-run').classList.remove('from-red-600', 'to-red-800', 'border-red-500');
                
                this.updateUI();
                this.updatePredictions();
            },

            runMonthTick() {
                if (!this.isSimulating) return;

                if (this.simMonth >= 12) {
                    this.finalizeResults();
                    return;
                }

                document.getElementById('sim-month').innerText = MONTHS[this.simMonth];
                document.getElementById('sim-year-prog').innerText = `MONTH ${this.simMonth + 1}/12`;
                
                document.getElementById('analysis-text').innerText = "SIMULATION ACTIVE: Monitor grid stability and weather events.";

                this.processEvents();
                this.calculateMonthlyStats();

                const delay = CONFIG.baseMonthDuration / this.speedMultiplier;
                this.simTimer = setTimeout(() => {
                    this.simMonth++;
                    this.runMonthTick();
                }, delay);
            },

            processEvents() {
                this.activeEvents = this.activeEvents.filter(e => {
                    e.duration--;
                    return e.duration > 0;
                });

                this.grid.forEach(t => t.disasterEffect = null);

                if (Math.random() < 0.25 && this.activeEvents.length === 0) {
                    this.triggerRandomDisaster();
                }

                let alertMsg = "";
                
                this.activeEvents.forEach(e => {
                    if (e.type === 'cloud') {
                        e.tiles.forEach(idx => {
                            if (this.grid[idx]) this.grid[idx].disasterEffect = 'effect-cloud';
                        });
                        alertMsg = "CLOUD COVER";
                    } 
                    else if (e.type === 'drought') {
                        this.grid.forEach(t => {
                            if (t.type === 'river') t.disasterEffect = 'effect-drought';
                        });
                        alertMsg = "DROUGHT";
                    }
                });

                if (alertMsg) this.showDisasterAlert(alertMsg);
                else this.hideDisasterAlert();

                this.renderGrid(); 
            },

            triggerRandomDisaster() {
                const roll = Math.random();
                
                if (roll < 0.4) {
                    const center = Math.floor(Math.random() * 64);
                    const offsets = [-9,-8,-7, -1,0,1, 7,8,9]; 
                    const affected = offsets.map(o => center + o).filter(i => i >= 0 && i < 64);
                    this.activeEvents.push({ type: 'cloud', duration: 3, tiles: affected });
                } 
                else if (roll < 0.7) {
                    this.activeEvents.push({ type: 'drought', duration: 4 });
                } 
                else {
                    this.handleStorm();
                }
            },

            handleStorm() {
                const flash = document.getElementById('storm-flash');
                flash.style.opacity = 0.8;
                setTimeout(() => flash.style.opacity = 0, 300);

                // Storms now only provide a temporary wind boost; no building failures.
                this.activeEvents.push({ type: 'storm-boost', duration: 1 });
                this.showDisasterAlert("STORM SURGE: WIND BOOST");
                this.showMessage("High winds detected. Wind output doubled!");
            },

            clearDisasters() {
                this.grid.forEach(t => t.disasterEffect = null);
                this.renderGrid();
            },

            calculateMonthlyStats() {
                const techLevelMultiplier = 1 + (this.upgradeLevel * CONFIG.upgrade.multiplierPerLevel);
                let monthlyProd = 0;
                let battCount = 0;
                let hasExportHub = false;
                let noiseFines = 0;

                const isDrought = this.activeEvents.some(e => e.type === 'drought');
                const isStormBoost = this.activeEvents.some(e => e.type === 'storm-boost');
                const cloudTiles = new Set();
                this.activeEvents.filter(e => e.type === 'cloud').forEach(e => e.tiles.forEach(t => cloudTiles.add(t)));

                this.grid.forEach((t, index) => {
                    // Skip if empty, town, construction or BROKEN
                    if (!t.building || t.building === 'town' || t.isConstruction || t.isBroken) return;
                    
                    if (t.building === 'export') {
                        hasExportHub = true;
                        return;
                    }

                    const stats = CONFIG.buildings[t.building];
                    
                    if (t.building === 'battery') {
                        battCount++;
                        this.simResults.envSum += stats.env; 
                    } else {
                        let seasonMod = SEASONALITY[t.building][this.simMonth];
                        let weatherBase = CONFIG.weather[t.building];
                        let output = stats.output;

                        let tileModifier = 1.0;
                        if (t.building === 'wind' && this.isNoiseZone(index)) {
                            noiseFines += CONFIG.noiseFine;
                        }

                        if (t.building === 'solar') tileModifier = t.sunCoverage;
                        // Tile modifier is now handled in the production loop below
                        // if (t.building === 'solar') tileModifier = t.sunCoverage;
                        if (t.building === 'solar' && cloudTiles.has(index)) output = 0; 
                        else if (t.building === 'hydro' && isDrought) output = 0; 
                        else if (t.building === 'wind' && isStormBoost) output *= 2; 

                        monthlyProd += (output * weatherBase * seasonMod * techLevelMultiplier);
                        this.simResults.envSum += stats.env;
                    }
                }); // This loop is only for display and battery capacity, not production

                this.maxBatteryCapacity = battCount * CONFIG.buildings.battery.capacity;

                if (noiseFines > 0) {
                    this.budget -= noiseFines;
                    const revEl = document.getElementById('revenue-float');
                    revEl.innerText = `-${noiseFines} (Noise)`;
                    revEl.classList.remove('text-neon-green');
                    revEl.classList.add('text-red-400');
                    revEl.style.opacity = 1;
                    setTimeout(() => {
                        revEl.style.opacity = 0;
                        revEl.classList.add('text-neon-green'); 
                        revEl.classList.remove('text-red-400');
                    }, 1500);
                }

                const baseMonthlyDemand = CONFIG.demand / 12;
                const seasonality = DEMAND_CURVE[this.simMonth];
                const growth = 1 + (this.simMonth * CONFIG.demandGrowth); 
                const currentTarget = Math.floor(baseMonthlyDemand * seasonality * growth);
                
                document.getElementById('ui-param-demand').innerText = `Target: ${currentTarget} MWh`;
                document.getElementById('ui-param-demand').className = "text-neon-orange font-mono animate-pulse"; 

                this.simResults.totalDemandSoFar += currentTarget;

                // Solar Intermittency Calculation (Rough Approximation)
                let solarProdTotal = 0;
                let otherProdTotal = 0;
                
                // Re-calculate split with sun and river boosts
                this.grid.forEach((t, index) => {
                    if (!t.building || t.building === 'town' || t.building === 'export' || t.building === 'battery' || t.isConstruction || t.isBroken) return;
                    const stats = CONFIG.buildings[t.building];
                    let seasonMod = SEASONALITY[t.building][this.simMonth];
                    let weatherBase = CONFIG.weather[t.building];
                    let output = stats.output;
                    
                    if (t.building === 'solar' && cloudTiles.has(index)) output = 0;
                    else if (t.building === 'hydro' && isDrought) output = 0;
                    else if (t.building === 'wind' && isStormBoost) output *= 2;

                    // Apply sun boost for solar and river boost for wind
                    let boostMultiplier = 1.0;
                    if (t.building === 'solar') {
                        boostMultiplier = this.getSunBoost(index);
                    } else if (t.building === 'wind') {
                        boostMultiplier = this.getNearbyRiverBoost(index);
                    }

                    const finalOutput = (output * weatherBase * seasonMod * techLevelMultiplier * boostMultiplier);
                    if (t.building === 'solar') solarProdTotal += finalOutput;
                    else otherProdTotal += finalOutput;
                });

                const solarDirect = solarProdTotal * 0.5;
                const solarToStore = solarProdTotal * 0.5;

                if (this.batteryCharge < this.maxBatteryCapacity) {
                    const space = this.maxBatteryCapacity - this.batteryCharge;
                    const chargeAmount = Math.min(solarToStore, space);
                    this.batteryCharge += chargeAmount;
                }

                const powerAvailable = otherProdTotal + solarDirect;
                const totalGeneratedForDisplay = solarProdTotal + otherProdTotal; 

                let netEnergy = powerAvailable - currentTarget;
                let isPowered = false;
                let batteryUsed = false;

                if (netEnergy >= 0) {
                    isPowered = true;
                    if (this.batteryCharge < this.maxBatteryCapacity) {
                        const space = this.maxBatteryCapacity - this.batteryCharge;
                        const chargeAmount = Math.min(netEnergy, space);
                        this.batteryCharge += chargeAmount;
                        netEnergy -= chargeAmount; 
                    }
                    if (hasExportHub && netEnergy > 0) {
                        const earnings = netEnergy * CONFIG.exportRate;
                        this.budget += earnings;
                        this.simResults.exportEarnings += earnings; // Track total earnings
                        const revEl = document.getElementById('revenue-float');
                        revEl.innerText = `+${Math.floor(earnings)}`;
                        revEl.style.opacity = 1;
                        setTimeout(() => revEl.style.opacity = 0, 1500);
                    }
                } else {
                    const deficit = Math.abs(netEnergy);
                    if (this.batteryCharge >= deficit) {
                        this.batteryCharge -= deficit;
                        isPowered = true;
                        batteryUsed = true;
                    } else {
                        this.batteryCharge = 0;
                        isPowered = false;
                    }
                }

                const batPct = this.maxBatteryCapacity > 0 ? (this.batteryCharge / this.maxBatteryCapacity) * 100 : 0;
                document.getElementById('battery-bar').style.width = `${batPct}%`;
                document.getElementById('stat-battery').innerText = `${Math.floor(this.batteryCharge)} / ${this.maxBatteryCapacity} MWh`;
                
                if (batPct < 20) document.getElementById('battery-bar').className = "h-full bg-red-500 transition-all duration-300";
                else if (batPct < 50) document.getElementById('battery-bar').className = "h-full bg-yellow-400 transition-all duration-300";
                else document.getElementById('battery-bar').className = "h-full bg-neon-green transition-all duration-300";

                if (isPowered) this.simResults.monthsPowered++;

                if (this.townPowered !== isPowered) {
                    this.townPowered = isPowered;
                    this.renderGrid();
                }
                
                document.getElementById('budget-display').innerText = Math.floor(this.budget);

                this.simResults.production += totalGeneratedForDisplay; 
                
                const currentMonthIndex = this.simMonth + 1;
                const expectedDemandSoFar = this.simResults.totalDemandSoFar;
                const pctMet = (this.simResults.production / expectedDemandSoFar) * 100;
                const safePct = Math.min(pctMet, 100);
                document.getElementById('bar-autonomy').style.width = `${safePct}%`;
                
                const reliabilityPct = (this.simResults.monthsPowered / currentMonthIndex) * 100;
                document.getElementById('bar-reliability').style.width = `${reliabilityPct}%`;
                document.getElementById('score-reliability').innerText = `${Math.floor(reliabilityPct)}%`;

                let outputColor = "text-white";
                if (!isPowered) outputColor = "text-red-500";
                else if (batteryUsed) outputColor = "text-yellow-400"; 

                document.getElementById('stat-capacity').innerHTML = `<span class="${outputColor}">${Math.floor(totalGeneratedForDisplay)}</span> <span class="text-xs text-gray-500 font-sans">MWh/mo</span>`;
                
                // Update production vs target bar
                const prodPct = Math.min((totalGeneratedForDisplay / Math.max(currentTarget, 1)) * 100, 100);
                document.getElementById('bar-production').style.width = `${prodPct}%`;
                document.getElementById('prod-status').innerText = `${Math.floor(totalGeneratedForDisplay)} / ${currentTarget} MWh`;
                
                const statusColor = isPowered ? "text-green-400" : "text-red-400";
                let statusText = isPowered ? "POWERED" : "BLACKOUT";
                if (isPowered && batteryUsed) statusText = "DRAINING BATTERY";
                
                const diff = totalGeneratedForDisplay - currentTarget;
                const diffText = diff >= 0 ? `+${Math.floor(diff)}` : `${Math.floor(diff)}`;
                
                document.getElementById('analysis-text').innerHTML = 
                    `<span class="${statusColor} font-bold">${statusText}</span>: Demand ${currentTarget} (${diffText})`;
                
                // Record monthly data for analysis
                this.monthlyHistory.push({
                    month: this.simMonth,
                    monthName: MONTHS[this.simMonth],
                    demand: currentTarget,
                    production: Math.floor(totalGeneratedForDisplay),
                    powered: isPowered,
                    batteryLevel: Math.floor(this.batteryCharge),
                    maxBattery: this.maxBatteryCapacity,
                    exports: hasExportHub ? Math.floor(netEnergy * CONFIG.exportRate) : 0
                });
            },

            finalizeResults() {
                this.stopSimulation();
                
                let count = 0;
                let assetValue = 0;

                this.grid.forEach(t => { 
                    if(t.building && t.building !== 'town' && !t.isConstruction) { 
                        if (t.building !== 'export') count++; 
                        assetValue += CONFIG.buildings[t.building].cost;
                    } 
                });

                const totalProd = this.simResults.production;
                const totalDemand = this.simResults.totalDemandSoFar;
                
                // --- SCORING FIXES ---
                
                // 1. Reliability Score (Uptime Based)
                const s2 = (this.simResults.monthsPowered / 12) * 10;

                // 2. Environment Score
                const avgEnvSumPerMonth = this.simResults.envSum / 12;
                const avgEnv = count > 0 ? (avgEnvSumPerMonth / count) : 0;
                const s3 = Math.min(avgEnv * 1.2, 10);

                // Autonomy
                const autoPct = totalProd / totalDemand; 

                // 3. Economic Performance Score (Valuation Based)
                const initialBudget = REGIONS[this.currentRegion].budget; 
                const liquidCash = this.budget;
                const depreciatedAssets = assetValue * 0.5; 
                const netWorth = liquidCash + depreciatedAssets;
                
                let econRatio = netWorth / initialBudget;
                const s4 = Math.min(econRatio * 10, 10);

                const s1 = Math.min(autoPct * 10, 10);
                
                const totalScore = (s1 * 400) + (s2 * 200) + (s3 * 200) + (s4 * 200);

                // Convert score to letter grade
                let letterGrade = 'F';
                if (totalScore >= 9000) letterGrade = 'A+';
                else if (totalScore >= 8500) letterGrade = 'A';
                else if (totalScore >= 8000) letterGrade = 'A-';
                else if (totalScore >= 7500) letterGrade = 'B+';
                else if (totalScore >= 7000) letterGrade = 'B';
                else if (totalScore >= 6500) letterGrade = 'B-';
                else if (totalScore >= 6000) letterGrade = 'C+';
                else if (totalScore >= 5500) letterGrade = 'C';
                else if (totalScore >= 5000) letterGrade = 'C-';
                else if (totalScore >= 4000) letterGrade = 'D';
                else if (totalScore >= 3000) letterGrade = 'E';

                // Save grade for next year logic
                this.lastYearGrade = letterGrade;
                this.lastYearScore = totalScore;

                // Calculate stats for modal
                const newBudget = Math.max(2000, Math.floor(totalScore));
                this.lastYearBudget = newBudget;
                const blackouts = 12 - this.simResults.monthsPowered;

                // Play end-game sound (use letter grade, not just blackouts)
                const failingGrades = ['C-', 'D', 'E', 'F'];
                if (failingGrades.includes(letterGrade)) {
                    this.playSound('fail');
                } else {
                    this.playSound('success');
                }


                this.animateBar('bar-autonomy', Math.min(autoPct * 100, 100), 'score-autonomy', Math.floor(autoPct*100) + '%');
                this.animateBar('bar-reliability', s2 * 10, 'score-reliability', Math.floor(s2*10) + '%');
                this.animateBar('bar-env', (s3/10) * 100, 'score-env', s3.toFixed(1));
                this.animateBar('bar-cost', (s4/10) * 100, 'score-cost', s4.toFixed(1));

                const finalEl = document.getElementById('final-score');
                finalEl.innerText = letterGrade;
                finalEl.style.fontSize = '4rem';
                finalEl.style.fontWeight = 'bold';

                // Save Score
                this.saveScore(totalScore);

                // Populate Modal
                document.getElementById('summary-score').innerText = letterGrade;
                document.getElementById('summary-budget').innerText = `${newBudget.toLocaleString()}cr`;
                
                // Breakdown Stats
                document.getElementById('summary-autonomy').innerText = `${Math.floor(s1 * 10)}/100`;
                document.getElementById('summary-reliability').innerText = `${Math.floor(s2 * 10)}/100`;
                document.getElementById('summary-environment').innerText = `${Math.floor(s3 * 10)}/100`;
                document.getElementById('summary-economy').innerText = `${Math.floor(s4 * 10)}/100`;

                document.getElementById('summary-uptime').innerText = `${this.simResults.monthsPowered}/12 Months`;
                document.getElementById('summary-blackouts').innerText = blackouts;
                document.getElementById('summary-exports').innerText = `${Math.floor(this.simResults.exportEarnings)} cr`;

                // --- Restart Budget Logic ---
                REGIONS[this.currentRegion].budget = newBudget; // Persist to region
                CONFIG.budget = newBudget; // Set for next reset

                this.lastYearBudget = newBudget; // Store for next year start
                                
                // Show Modal
                const modal = document.getElementById('summary-modal');
                modal.classList.remove('hidden');
                requestAnimationFrame(() => modal.classList.add('visible'));

                // Update Button to "Next Year" mode
                // The reset() function now handles restoring the button state.

                let txt = "Yearly cycle complete. ";
                if (this.simResults.monthsPowered < 12) txt += "BLACKOUTS DETECTED. Improve storage or generation. ";
                else if (econRatio >= 1.0) txt += "PROFITABLE & VALUABLE GRID. Outstanding management. ";
                else if (autoPct < 1) txt += "Demand met via batteries, but generation low. ";
                else txt += "Grid stable. Good work, Architect.";
                
                document.getElementById('analysis-text').innerHTML = 
                    `${txt} <br><span class="text-neon-green font-bold">BUDGET UPDATED: ${newBudget.toLocaleString()} Credits awarded based on score.</span>`;
                
                document.getElementById('ui-param-demand').className = "text-blue-400 font-mono";
            },
            
            closeSummaryAndNextYear() {
                const modal = document.getElementById('summary-modal');
                modal.classList.remove('visible');
                setTimeout(() => modal.classList.add('hidden'), 300);
                
                // Check if grade is less than C (C-, D, E, F)
                const failingGrades = ['C-', 'D', 'E', 'F'];
                
                if (failingGrades.includes(this.lastYearGrade)) {
                    // Redo the game - clear buildings but keep the map terrain
                    this.grid.forEach(tile => {
                        if (tile.building && tile.building !== 'town') {
                            tile.building = null;
                        }
                        tile.isConstruction = false;
                        tile.isBroken = false;
                        tile.disasterEffect = null;
                    });
                    
                    // Reset budget and other game state
                    this.budget = CONFIG.budget;
                    this.upgradeLevel = 0;
                    this.selectedTool = null;
                    this.updateBuildCursor();
                    this.activeEvents = [];
                    this.activeBuilders = 0;
                    this.hideDisasterAlert();
                    
                    this.renderGrid();
                    this.updateUI();
                    this.updatePredictions();
                    
                    document.getElementById('analysis-text').innerHTML = 
                        `<span class="text-red-400 font-bold">INSUFFICIENT GRADE: Redo the year with the same map.</span>`;
                } else {
                    // Passed - keep everything and start next year with updated budget
                    const expansion = this.expandTownForNewYear();
                    this.budget = this.lastYearBudget;
                    CONFIG.budget = this.lastYearBudget;
                    REGIONS[this.currentRegion].budget = this.lastYearBudget;
                    
                    if (expansion.tiles > 0) {
                        this.showMessage(`New town growth: +${expansion.tiles} tile(s). Demand +${expansion.demandIncrease} MWh/yr`);
                        this.renderGrid();
                    }
                    this.updateUI();
                    this.updatePredictions();
                    document.getElementById('analysis-text').innerHTML = `<span class="text-neon-green font-bold">NEW YEAR: Demand adjusted to ${CONFIG.demand.toLocaleString()} MWh.</span>`;
                }
            },

            backToStart() {
                this.stopSimulation();
                this.selectedTool = null;
                this.updateBuildCursor();
                this.hideDisasterAlert();
                const start = document.getElementById('start-screen');
                start.style.display = 'flex';
                requestAnimationFrame(() => start.style.opacity = 1);
                
                // Hide other modals
                const regionModal = document.getElementById('region-select-modal');
                if (regionModal) {
                    regionModal.classList.remove('visible');
                    regionModal.classList.add('hidden');
                }
                const summary = document.getElementById('summary-modal');
                if (summary) {
                    summary.classList.remove('visible');
                    summary.classList.add('hidden');
                }
            },

            toggleBuildMenu() {
                const content = document.getElementById('build-menu-content');
                if (content) content.classList.toggle('hidden');
            },

            
            animateBar(id, pct, txtId, txtVal) {
                document.getElementById(txtId).innerText = txtVal;
                setTimeout(() => {
                    document.getElementById(id).style.width = pct + '%';
                }, 100);
            },

            // ===== GAME TUTORIAL SYSTEM =====
            tutorialGameStep: 0,
            tutorialGameActive: false,

            tutorialGameSteps: [
                {
                    title: "Welcome, Architect!",
                    text: "You've been tasked with managing the energy grid for this region. Let me show you the key elements of your mission.",
                    target: null,
                    centered: true
                },
                {
                    title: "Your Budget",
                    text: "This is your starting budget in Credits. Use it wisely to build solar panels, wind turbines, hydroelectric plants, and battery storage systems.",
                    target: "header .flex.items-center.bg-\\[\\#1e293b\\]:last-of-type",
                    centered: false
                },
                {
                    title: "Available Builders",
                    text: "You can construct up to 3 buildings simultaneously. When all builders are occupied, you'll need to wait for one to finish before starting a new project.",
                    target: "header .flex.items-center.bg-\\[\\#1e293b\\]:nth-of-type(2)",
                    centered: false
                },
                {
                    title: "The Energy Grid",
                    text: "This is your 8x8 grid where you'll build energy infrastructure. Click on tiles to place buildings. Avoid building on forests, mountains, and rivers unless building hydroelectric plants on rivers.",
                    target: ".map-grid",
                    centered: false
                },
                {
                    title: "Ready to Begin!",
                    text: "You now understand the basics. Use the BUILD MENU on the right to select what to construct. Run the SIMULATION to see if you meet the town's energy demands. Good luck!",
                    target: null,
                    centered: true
                }
            ],

            startGameTutorial() {
                this.tutorialGameStep = 0;
                this.tutorialGameActive = true;
                const overlay = document.getElementById('game-tutorial-overlay');
                overlay.classList.add('active');
                this.showGameTutorialStep();
            },

            showGameTutorialStep() {
                if (this.tutorialGameStep >= this.tutorialGameSteps.length) {
                    this.endGameTutorial();
                    return;
                }

                const step = this.tutorialGameSteps[this.tutorialGameStep];
                const box = document.getElementById('tutorial-box-game');
                const titleEl = document.getElementById('tutorial-game-title');
                const textEl = document.getElementById('tutorial-game-text');
                const stepEl = document.getElementById('tutorial-game-step');
                const nextBtn = document.getElementById('tutorial-game-next');
                const skipBtn = document.getElementById('tutorial-game-skip');

                // Update content
                titleEl.textContent = step.title;
                textEl.textContent = step.text;
                stepEl.textContent = `Step ${this.tutorialGameStep + 1} of ${this.tutorialGameSteps.length}`;
                nextBtn.textContent = this.tutorialGameStep === this.tutorialGameSteps.length - 1 ? "Start Building! →" : "Next →";

                // Remove previous event listeners and attach new ones
                const newNextBtn = nextBtn.cloneNode(true);
                nextBtn.replaceWith(newNextBtn);
                newNextBtn.onclick = () => this.nextGameTutorialStep();

                const newSkipBtn = skipBtn.cloneNode(true);
                skipBtn.replaceWith(newSkipBtn);
                newSkipBtn.onclick = () => this.endGameTutorial();

                // Handle targeting and positioning
                this.removeGameTutorialHighlight();

                if (step.centered) {
                    this.centerGameTutorialBox();
                } else if (step.target) {
                    // Use querySelector-compatible selector
                    let target = null;
                    try {
                        if (step.target === "header .flex.items-center.bg-\\[\\#1e293b\\]:last-of-type") {
                            const headerElements = document.querySelectorAll("header .flex.items-center.bg-\\[\\#1e293b\\]");
                            target = headerElements[headerElements.length - 1];
                        } else if (step.target === "header .flex.items-center.bg-\\[\\#1e293b\\]:nth-of-type(2)") {
                            const headerElements = document.querySelectorAll("header .flex.items-center.bg-\\[\\#1e293b\\]");
                            target = headerElements[0];
                        } else {
                            target = document.querySelector(step.target);
                        }
                    } catch (e) {
                        console.log("Selector error:", e);
                    }

                    if (target) {
                        this.highlightGameTutorialTarget(target);
                        this.positionGameTutorialBox(target, box);
                    } else {
                        this.centerGameTutorialBox();
                    }
                } else {
                    this.centerGameTutorialBox();
                }
            },

            highlightGameTutorialTarget(element) {
                const rect = element.getBoundingClientRect();
                const spotlight = document.getElementById('tutorial-spotlight-game');
                
                spotlight.style.left = (rect.left - 8) + 'px';
                spotlight.style.top = (rect.top - 8) + 'px';
                spotlight.style.width = (rect.width + 16) + 'px';
                spotlight.style.height = (rect.height + 16) + 'px';
                spotlight.style.display = 'block';
            },

            removeGameTutorialHighlight() {
                const spotlight = document.getElementById('tutorial-spotlight-game');
                spotlight.style.display = 'none';
            },

            positionGameTutorialBox(target, box) {
                const rect = target.getBoundingClientRect();
                const boxWidth = box.offsetWidth || 550;
                const boxHeight = box.offsetHeight || 300;
                const gap = 25;
                const padding = 20;

                // Calculate position: below target
                const targetCenterX = rect.left + rect.width / 2;
                let left = targetCenterX - boxWidth / 2;
                let top = rect.bottom + gap;

                // Keep in viewport
                if (left < padding) left = padding;
                if (left + boxWidth > window.innerWidth - padding) {
                    left = window.innerWidth - boxWidth - padding;
                }

                if (top + boxHeight > window.innerHeight - padding) {
                    top = rect.top - boxHeight - gap;
                    if (top < padding) top = padding;
                }

                box.style.left = left + 'px';
                box.style.top = top + 'px';
                box.style.transform = 'none';
                box.classList.remove('centered');
            },

            centerGameTutorialBox() {
                const box = document.getElementById('tutorial-box-game');
                box.style.left = '50%';
                box.style.top = '50%';
                box.style.transform = 'translate(-50%, -50%)';
                box.classList.add('centered');
            },

            nextGameTutorialStep() {
                this.tutorialGameStep++;
                if (this.tutorialGameStep >= this.tutorialGameSteps.length) {
                    this.endGameTutorial();
                } else {
                    this.showGameTutorialStep();
                }
            },

            endGameTutorial() {
                this.tutorialGameActive = false;
                const overlay = document.getElementById('game-tutorial-overlay');
                overlay.classList.remove('active');
                this.removeGameTutorialHighlight();
                
               
            }
        };


        window.onload = () => game.init();

    </script>
</body>
</html> 
