import express from 'express';
import { OpenAI } from "openai";
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const app = express();
const PORT = 3000;

app.use(express.json());
app.use(express.static(__dirname));

if (!process.env.HF_API_KEY) {
	const envPath = path.join(__dirname, '.env');
	if (fs.existsSync(envPath)) {
		const content = fs.readFileSync(envPath, 'utf-8');
		content.split(/\r?\n/).forEach(line => {
			const trimmed = line.trim();
			if (!trimmed || trimmed.startsWith('#')) return;
			const eqIdx = trimmed.indexOf('=');
			if (eqIdx === -1) return;
			const key = trimmed.slice(0, eqIdx).trim();
			const value = trimmed.slice(eqIdx + 1).trim();
			if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
				process.env[key] = value;
			}
		});
	}
}

const HF_API_KEY = process.env.HF_API_KEY;
if (!HF_API_KEY) {
	console.error("Missing HF_API_KEY environment variable. Set it in your .env file.");
	process.exit(1);
}

const client = new OpenAI({
	baseURL: "https://router.huggingface.co/v1",
	apiKey: HF_API_KEY,
});

const GAME_CONTEXT = `
Core Gameplay & Mechanics
The game is played on an 8x8 tile grid, representing the region to be developed.

Objective & Winning Condition:

The main goal is to successfully power the town for 12 simulated months without suffering from blackouts.
Success is measured by a final score calculated from four key metrics: Autonomy (self-sufficiency), Reliability (uptime/months powered), Environment (eco-friendliness of the grid), and Economy (profitability and net worth).
A high score results in a larger starting budget for the next "year," creating a persistent gameplay loop.
Regions & Scenarios:

Players can choose from four distinct regions: Atlantic Village, Sunrise Desert, North Fjord, and Windy Plains.
Each region has unique characteristics, including different starting budgets, baseline energy demands, and environmental yields (e.g., the desert has high solar yield but very low hydro potential). This adds replayability and strategic depth.
Grid & Terrain:

The 8x8 grid features several terrain types that influence strategy:
Land: The basic tile for most construction.
River: Required for building Hydro Plants.
Forest & Mountain: Obstacles that cannot be built upon.
Town: A multi-tile unbuildable area representing the civilization that must be powered.
Energy Technologies & Buildings: Players have a selection of technologies to build, each with strategic trade-offs:

Solar Panel: Moderate cost and output. Highly effective in sunny regions but output is reduced by 50% (simulating nighttime) unless paired with batteries. Vulnerable to "Cloud Cover" events.
Wind Turbine: High cost and high output. Benefits from storms and proximity to rivers but incurs a "noise fine" if built too close to the town.
Hydro Plant: Consistent and reliable power source that requires a river tile. It is immune to cloud cover but can be completely disabled by "Drought" events.
Battery Storage: Stores excess energy. Essential for making solar panels fully effective and for providing a buffer to prevent blackouts when demand exceeds real-time production.
Export Hub: A high-cost building that allows the player to sell surplus energy to a wider grid, generating income.
Upgrades: Players can spend credits to purchase global efficiency upgrades, which boost the output of all their power-generating buildings.
Economic Model:

Budget: Players start with a fixed number of "Credits" determined by the chosen region.
Expenses: Every action has a cost: building, repairing damaged units, and purchasing upgrades.
Revenue: Income is generated by selling excess power through an Export Hub.
Scoring: At the end of the year, the player's final score is converted into the starting budget for the next year, rewarding good performance.
Simulation & Dynamic Events:

The game simulates a full year, month by month.
Seasonality: Energy demand and the output of solar, wind, and hydro plants fluctuate realistically based on the season.
Dynamic Events: Random events occur, forcing the player to adapt:
Cloud Cover: Reduces solar output but increases wind.
Drought: Temporarily disables all hydro plants.
Storms: Can either boost wind turbine output or damage them, requiring costly repairs.
Blackouts: If production and stored battery power cannot meet demand, the town experiences a blackout, severely impacting the final score.`;

app.post('/api/advisor', async (req, res) => {
	try {
		const { gridState, budget, demand, production, buildingBreakdown, energyBalance, batteryInfo, terrain, budgetStatus, regionOptimization, region, upgradeLevel, availableLandSlots, limits } = req.body;
		
		const buildingCount = gridState ? gridState.filter(t => t.building).length : 0;
		const forestCount = gridState ? gridState.filter(t => t.type === 'forest').length : 0;
		const mountainCount = gridState ? gridState.filter(t => t.type === 'mountain').length : 0;
		const riverCount = gridState ? gridState.filter(t => t.type === 'river').length : 0;

		// Determine regional strengths
		const solarYield = Math.round((regionOptimization?.solar?.suitability || 0) * 100);
		const windYield = Math.round((regionOptimization?.wind?.suitability || 0) * 100);
		const hydroYield = Math.round((regionOptimization?.hydro?.suitability || 0) * 100);
		
		// Base building outputs (MWh per month)
		const baseSolarOutput = 100;
		const baseWindOutput = 150;
		const baseHydroOutput = 120;

		// Average building output considering regional yield
		const avgSolarOutput = Math.round(baseSolarOutput * (solarYield / 100));
		const avgWindOutput = Math.round(baseWindOutput * (windYield / 100));
		const avgHydroOutput = Math.round(baseHydroOutput * (hydroYield / 100));

		// Identify strongest energy sources
		const strengths = [];
		if (solarYield >= 50) strengths.push("Solar");
		if (windYield >= 50) strengths.push("Wind");
		if (hydroYield >= 50) strengths.push("Hydro");
		
		const strengthsText = strengths.length > 0 ? `Strong sources: ${strengths.join(', ')}. ` : '';
		const hydroWarning = hydroYield < 30 ? `CRITICAL: Hydro yield is only ${hydroYield}% - DO NOT recommend hydro plants. ` : '';
		const hydroNotable = hydroYield >= 30 && hydroYield < 60 ? `Note: Hydro is marginal at ${hydroYield}% - only if rivers are abundant. ` : '';
		const strongSources = strengths.length > 0 ? strengths.join(' and ') : 'available high-yield sources';
		const hydroCondition = hydroYield >= 60 ? 'yield is strong' : 'you confirm rivers are available';

		// Solar-Battery Synergy Rule
		const solarBatteryRule = (buildingBreakdown?.solar || 0) > (batteryInfo?.count || 0) ? `CRITICAL: You have solar panels but not enough batteries. Solar is only 33% effective without batteries to store night power. Recommend building more batteries. ` : '';

		// Economic and build limit context
		const budgetAlert = budget < 1000 ? `LOW BUDGET WARNING: You have less than 1000 credits. Advise caution or selling power. ` : '';
		const landAlert = availableLandSlots < 5 ? `LIMITED LAND: Only ${availableLandSlots} buildable slots remain. Plan carefully. ` : '';
		const exportHubContext = (buildingBreakdown?.export || 0) > 0 ? 'Player can sell excess power. ' : 'Player cannot sell power yet. ';

		// Static cost table to avoid undefined references
		const costs = {
			solar: 450,
			wind: 700,
			hydro: 600,
			battery: 200,
			export: 1200
		};

		// Remaining build caps based on limits and current counts
		const remainingCap = {
			solar: Math.max(0, (limits?.solar ?? 0) - (buildingBreakdown?.solar ?? 0)),
			wind: Math.max(0, (limits?.wind ?? 0) - (buildingBreakdown?.wind ?? 0)),
			hydro: Math.max(0, (limits?.hydro ?? 0) - (buildingBreakdown?.hydro ?? 0)),
			battery: Math.max(0, (limits?.battery ?? 0) - (buildingBreakdown?.battery ?? 0)),
			export: Math.max(0, (limits?.export ?? 0) - (buildingBreakdown?.export ?? 0)),
		};

		const prompt = `ROLE: You are an elite energy grid strategist.
GOAL: Recommend immediate building actions to solve energy deficits or optimize surplus.
GAME CONTEXT: ${GAME_CONTEXT}


GAME STATE:
- Budget: ${budget} (${budgetStatus?.percentUsed}% used). Alert: ${budgetAlert ? 'ACTIVE' : 'None'}
- Yearly Demand vs Monthly Production: ${demand} vs ${production} MWh
- NET STATUS: ${energyBalance?.balance} MWh (${energyBalance?.balance < 0 ? 'DEFICIT - CRITICAL' : 'Surplus'})
- Terrain: ${availableLandSlots} buildable slots. ${riverCount} River tiles.
- Yields: Solar ${solarYield}%, Wind ${windYield}%, Hydro ${hydroYield}%
- Available Land: ${availableLandSlots} slots. Alert: ${landAlert ? 'ACTIVE' : 'None'}
- Export Hub: ${buildingBreakdown?.export || 0} units. ${exportHubContext}
- Build Caps Remaining: Solar ${remainingCap.solar}, Wind ${remainingCap.wind}, Hydro ${remainingCap.hydro}, Battery ${remainingCap.battery}, Export ${remainingCap.export}

CURRENT GRID & RATIOS:
- Solar: ${buildingBreakdown?.solar} || Batteries: ${batteryInfo?.count} (Current Ratio: 1:${(buildingBreakdown?.solar / (batteryInfo?.count || 1)).toFixed(1)})
- Wind: ${buildingBreakdown?.wind}
- Hydro: ${buildingBreakdown?.hydro}

BUILDING SPECS (Output/Cost):
- Solar: ${avgSolarOutput}MWh / ${costs.solar}c
- Wind: ${avgWindOutput}MWh / ${costs.wind}c
- Hydro: ${avgHydroOutput}MWh / ${costs.hydro}c
- Battery: Stores 50MWh / ${costs.battery}c

HARD CONSTRAINTS (DO NOT BREAK):
- Do not recommend more total buildings than availableLandSlots.
- Do not exceed current budget. Keep total cost <= ${budget}.
- Use whole numbers only; round battery counts down to whole units.
- Do not exceed per-type caps: Solar ${remainingCap.solar}, Wind ${remainingCap.wind}, Hydro ${remainingCap.hydro}, Battery ${remainingCap.battery}, Export ${remainingCap.export}.

CONSTRAINTS & RULES:
1. WORD LIMIT: 30 words maximum. Be direct.
2. CRITICAL: If Budget used > 90%, only recommend cheapest effective option.
3. BATTERY RULE: Target a 1:4 Battery-to-Solar ratio. If Solar > 0 and ratio is poor, prioritize Batteries, but never exceed budget or land slots.
4. PRIORITY: ${strongSources}

TASK:
Analyze Net Status and Budget. Provide a specific recommendation (Building Type + Quantity) that fits both budget and land slots.
`;

		const chatCompletion = await client.chat.completions.create({
			model: "meta-llama/Llama-3.1-70B-Instruct",
			messages: [{
				role: "system",
				content: prompt
			}],
			max_tokens: 2000
		});

		const advice = chatCompletion.choices[0].message.content;
		res.json({ message: advice });
	} catch (err) {
		console.error('Advisor error:', err);
		res.status(500).json({ message: "Advisor encountered an error. Try again later." });
	}
});

app.get('/', (req, res) => {
	res.sendFile(path.join(__dirname, 'react.html'));
});

app.listen(PORT, () => {
	console.log(`ðŸŽ® Energy Game running on http://localhost:${PORT}`);
	console.log(`ðŸ¤– Advisor API available at http://localhost:${PORT}/api/advisor`);
});
